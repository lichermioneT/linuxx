进程间同行
  共享内存
1.共享内存的原理
 pcb---进程地址空间---页表---物理内存
 
 共享内存
 1.申请一块空间，TODO
 2.创建好的内存空间，映射到进程的地址空间！ 挂接起来
 3.未来不想通信了，取消进程和内存的映射关系，然后释放内存.去关联。释放共享内存。
 
 理解
 a.进程间通信，是专门设计的，用来IPC
 b.共享内存是一种通信的方式，所有想通信的人，都可以用。
 c.OS一定可能会同时存在的很多的共享内存

2.共享内存的概念
  通过让不同进程，看到同一个内存块的方式：共享内存

shmget() 下面三个参数
key_t key
size_t size
int shmflg

shmflg
IPC_CREAT:不存在就创建，存在就获取信息
IPC_EXCL：1.不能单独的使用，2.IPC_CREAT | IPC_EXCL:不存在就创建，存在则返回错误，(用户，得到一个新的共享内存)
size:共享内存的大小
return value:失败-1，成功是标识符。数组下标。
key:是什么不重要，能进行唯一性标识最重要。ftok函数,ftok(char* patnmame, char proj__id);

shmget(key size flag) ;
在来理解key：
1.os同时存在共享内存---》  申请的内存也是先描述，后组织起来的
    共享内存也是如此（申请，释放）---》先描述，后组织。
    共享内存 == 物理内存块 + 共享内存的相关属性。

2.申请空间TODO---------》
  
3.是什么不重要，能进行唯一标识-》
  创建共享内存的时候，怎么保证共享内存是唯一的。key！
  另一个进程也看到同一个key就行了
  key在哪儿？共享内存的对应属性里面的。struct shm{int key}
  shmget(k,size,flag): 为什么不直接使用key作为标识符呢？ 为了和解耦(学校学号，员工员工号，内核层和用户层)


如何查看ipc资源
  ipcs -m/-q/-s

ipc资源的特征
  共享内存的生命周期是随OS的，不是随进程的（lpcs -m) (system v版本的特征)
  ipcrm -m id 删除共享内存

shell脚本
while true; do command1; command2; done;

shmat() // id 指定空间的映射，权限，一般是零
返回值就是虚拟地址的起始地址

共享内存的优点
  所有进程间通信最快的!大大减少数据拷贝的速度。综合考虑管道和共享内存，考虑键盘输入和显示器输出。共享内存几次拷贝？管道几次拷贝？
  管道
  char buffer                char buffer 
             write 管道 read
  共享内存
  输入           输出
        共享内存

共享内存的缺点
  不给我进行同步和互斥操作，没有对数据进行任何保护！对共享内存进行保护，你如何实现呢？ 写完，通知读端读取。没有通知的时候，server等待。
  创建一个管道，通知共享内存进行数据读取。


共享内存的内核结构
 shmctl()


共享内存的大小
  共享内存建议4kb的整数倍。
  系统分配共享内存是以4kb为单位的！，会向上取整





