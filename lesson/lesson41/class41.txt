协议就是一种约定
分层结构，分层高内聚，底耦合。
添加协议报头。解包和分用。
局域网通信的原理
跨网络通信：通过路由器，屏蔽底层协议。

报头和有效载荷。
IPV4:AMERICAN
IPV6:CHINA

ipv4:32位。点分十。
两套：
1从哪里来，到哪里去。           终极目标，目的ip(源IP)。未来每一个阶段，提供方向目标，方便进行路径选择。   方向
2上一站从哪里来，下一站去哪里。  该类地址，一直在变化。MAC地址。                                        可行性
开始学习---找工作
(c语言，数据结构，c++, linux系统，Linux网络编程)

IP地址：
IP地址是在IP协议中, 用来标识网络中不同主机的地址;
MAC地址：
MAC地址用来识别数据链路层中相连的节点; 

传输层和网络层在OS里面。

MAC地址一值变化的
IP地址A                           IP地址B
应用层                            应用层
传输层       MAC1       MAC...    传输层
网络层      网络层                网络层
数据链路层  数据链路层    ...      数据链路层
物理层      物理层                物理层
下           上下        ...      上

数据都必须在物理层上面跑


网络编程套接字
源  ip地址：发送端:从哪儿来
目的ip地址：接受端:到哪儿去
从哪儿来--到哪儿去

IPA          ....路由器....            IPB

我们把数据从A主机送到B主机是目的吗？不是,
真正通信的，不是这两个机器！
其实这两台机器上面的软件(人)

数据有IP(公网IP)标识一台唯一的主机
用谁来标识各: 主机上客户或者服务进程的唯一性呢？
为了更好的表示一台主机上服务进程的唯一性，我们采用端口号port，标识服务器进程，客户进程的唯一性。
1.ip地址(主机全网唯一性) + 该主机上的端口号，标识该服务器上进程的唯一性。
  ipA + portA,  ipB + portB
  该主机上对应的服务进程，在全网中是唯一的一个进程。ip + port。
  该主机上对应的服务进程，在全网中是唯一的一个进程。ip + port。
  网络通信的本质：

网络通信的本质：其实就是进程间通信！！

服务端   网络   客户端
  1.进程间通信，先让不同的进程看到同一份资源----网络
  2.通信不就是在做IO吗？---- 所有我们所有的上网行为：无外乎两种：我要把我的数据发出去。我要收到别人发给我的数据。

2ip保证全网唯一（这里是公网IP），port保证在主机内部的唯一性。

3进程已经有了pid，为什么有还需要port呢？
  1.系统是系统，网络是网络。单独设置---为了系统和网络解耦。
  2.需要客户端每次都能找到服务器进程--服务器的唯一性不能做任何改变。IP+PORT不能随便改变的。不能随意改变。不能使用轻易会改变的值。 
  3.不是所有的进程都需要提供网络服务或者请求，但是所有的进程都需要pid。这就是为什么不使用pid标定在网络中的唯一性。 

4进程 + port ---》网络服务进程 
  底层OS如何根据port找到指定的进程---》uint16-->task_struct -->hash(基于端口号 key, value pcb地址) pcb 文件 文件缓冲区。
  pcb可能是多个数据结构的 点。多种数据结构的组合点。

一个进程可以绑定多个端口号，但是一个端口号不能被多个进程绑定。
我们在网络通信的过程中，IP+PORT标识唯一性  client-->server。除了数据，需要把自己的ip和port发给对方吗？需要的，我们还要发回来 
未来发数据的时候，一定会  多发 一部分数据--以协议的形式呈现。

端口号是传输层协议的内容：
  传输层的端口号。

传输层协议
TCP协议：TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议。
  传输层协议
  有连接
  可靠传输
  面向字节流：TCP 传输数据的时候，不关心消息（message）边界，只把所有数据当成一串连续的字节流来传输。
UDP协议：UDP 是一种无连接的、不可靠的传输层通信协议。
  传输层协议
  无连接
  不可靠传输
  面向数据报：面向数据报 = 有边界、每个消息独立传输，发送端的一个数据报对应接收端的一个数据报。
面向数据报（UDP）：每个包独立、有边界、不能被拆或合并，可能丢失、乱序、不可靠但速度快。
面向字节流（TCP）：数据无边界，是连续字节流，可能粘包、拆包，但可靠、顺序。

不可靠和可靠是中性词。
可靠是有成本的---这样的协议往往是复杂的---维护&&编码
不可靠-----------这样的协议往往比较简单---维护和使用
挑选合适的场景。

发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出;

c语言：小小小。小端。
网络字节序列
接受方，怎么知道是发送的数据是大小端？？
规定网络中的数据都是大端。
网络字节流：
发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出。++简单

网络字节序：网络字节序 = 规定使用大端字节序（Big-Endian）来表示多字节数据。
0x12345678
网络字节序（大端）：
12 34 56 78

h: host主机
n: net网络
l: long 32字节
s: short 16字节
uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);

通信：我们写的代码是应用层方面。

ip + port:== 套接字
socket:插座

1网络套接字编程：跨主机和网络
2原始套接字：
3Unix域间套接字：
三套不同的接口。只是设计一套接口，通过参数的不同，解决所有网络或者其他场景下的通信问题。


.....

设计这一套c语言不支持void*
操作系统级别的接口
// 多态
struct sockadd
struct sockadd_in
struct sockadd_un

UDP协议

socket编程

                ┌──────────────────────┐
                │ struct sockaddr      │  ← bind/connect 接口需要它
                └──────────────────────┘
                          ▲
                          │（强制类型转换）
                          │
 ┌────────────────────────┼─────────────────────────┐
 │                        │                         │
 │                        │                         │
 ▼                        ▼                         ▼
sockaddr_in         sockaddr_in6               sockaddr_un
（IPv4）             （IPv6）                    （本地通信）

