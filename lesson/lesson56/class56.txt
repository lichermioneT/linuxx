三次握手是机制，并不是一定成功的。
四次挥手是机制，并不是一定成功的。

C                     S
        1.SYN值1--》         SYN_SEND
        2.《----- SYN+ACK    SYN_REVD
建立成功 3.ACK----》          建立成功
        握手完成。

握手不一定成功。
为什么要三次握手呢？
一次握手行不行呢？绝对不行的。Server一定要维护已经建立好的链接。SYN洪水。
两次握手行不行呢？同上的问题。SYN洪水。

三次握手：
a.使用最小成本验证全双工通信道是通畅的。 一进一出。
b.三次握手可以有效防止 单机进行对服务器进行攻击。
    服务器收到攻击，本身就不应该是tcp握手解决的！
    肉鸡
    
四次握手行不行呢？五次握手行不行呢？。。。。

三次握手其实可以理解成为四次握手。SYN和ACK可以分开。

为什么要三次握手呢？
预备
1.三次握手不一定非得成功，最担心的其实 是最后一个ACK丢失，但是有配套的解决方案。
2.链接需要被管理起来的，被OS管理起来的，先描述，后组织。维护一个链接需要成本的[时间和空间成本]


为什么一定是四次挥手呢？
建立链接一方主动
断开链接是双方的事情，需要征得双方的同意。

client                                                   server 
       1.我不想给你发消息了，我发完了，我要断开连接。--》FIN
       2.《----------------------ACK应答
       
       1.《----我不想给你发消息了，我发完了，我要断开连接。FIN
       2.ACK应答-----------------------------------》

    这里所谓的不发数据，指的是不发用户数据！
    TCP不知道，但是用户知道。
    ---上层会调用close(fd)
   
    并不代表底层没有管理报文的交换。

TCP为什么要连接》因为要保证可靠性。

主动断开链接的一方，最终状态是TIME_WAIT状态
被动断开链接的一方，两次挥手完成，会进入CLOSE_WAIT状态。
    和对方是C或者S无关系的。TCP是地位对等的协议。


如果我们的服务器出现大量的close_wait
1.服务器有bug，没有做close文件描述符的动作
2.服务器有压力，可可能一直在推送消息给client，导致来不及close.

TIME_WAIT 四次挥手动作已经完成了，但是主动断开连接的一方要维持一段时间的TIME_WAIT。一般是多长时间为什么？2MSL。
  1.FIN发送
  2.ACK发送
  1.保证最后一个ACK尽可能的被对方收到
  2.双方在断开的时候,网络中还有滞留的报文---保证滞留报文进行消散.教材给的理由。
  
服务器有时候可以出现立即重启，有时候无法重启。bind_err.TIME_WAIT的状态。 
如何解决立即重启呢？这个问题的危害，实际爆发的场景。

滑动窗口
流量控制(重传的成本太高)对方的接收能力判断。j
发送方怎么在第一次就知道对方的接收能力？？在通信之前，早就做过三次握手，交换窗口大小。
  窗口探测。
  


滑动窗口
如果我们发送数据，没有收到应答之前，我们必须将自己已经发送的数据
暂时保存起来，为了支持超时重传。
  保存在哪里呢？ 发送缓冲区。

大量的串行。


Client                                                    Server
发送缓冲区                                              接收缓冲区
1.已经发送&&收到应答的
2.已经发送的，但是没有收到应答的。滑动窗口。
3.数据尚未发送，没有数据，只有空间。
123.
2就是滑动窗口，本质就是发送区的一块空间。

0.窗口的大小开始是怎么设定的？未来怎么变化。
1.窗口一定会向右滑动吗？会向左滑动吗？
2.窗口一定会一直不变吗？会变大吗？会变小吗？为什么。变的依据是什么？
3.收到确认应答的时候，如果 不是最左侧发送的报文的确认，而是中间的，结尾的等怎么办？需要滑动吗？
4.滑动窗口必须滑动吗？会不会不动了，或者变为0了。
5.一直向后滑动吗？如果空间不够了怎么办？

建模1：
  如何看待滑动窗口问题
  char outbuffer[N]
  win_start win_end 数组下标，所谓的窗口移动 本质就是 下标在进行更新！

0.窗口的大小开始是怎么设定的？未来怎么变化。
目前：滑动窗口的大小，和对方的接收能力有关
  win_start = 0; win_end = win_start + tcp_win--未来怎么滑动，都有保证对方能够正常接收。
  滑动窗口 大小=对方通告给我的 自己的接收能力大小【目前】。

1.窗口一定会向右滑动吗？会向左滑动吗？
 一定不会向左边滑动。不一定向右滑动。可能向右滑动，可能保持。
 win_start=ACK_SEQ 
 win_end = win_start + tcp_win.


2.窗口一定会一直不变吗？会变大吗？会变小吗？为什么。变的依据是什么？
  不会的，              会的      会的              根据对方缓冲区

3.收到确认应答的时候，如果 不是最左侧发送的报文的确认，而是中间的，结尾的等怎么办？需要滑动吗？
  丢包
  1.数据没丢，只是应答丢失了
  2.数据真的丢了
  确认序号的定义:ACK seqX+1,表示X+1之前的所有数据全部收到了。支持我们的滑动窗口的滑动规则设定。

4.滑动窗口必须滑动吗？会不会不动了，或者变为0了。
  不是必须滑动的。
   
5.一直向后滑动吗？如果空间不够了怎么办？
   保存在滑动窗口里面！

建模2：
  发送缓冲区被内核组织成为了环形结构。
  


































