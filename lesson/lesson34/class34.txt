原生线程库
线程id，线程库结构体对象的id
线程栈--库里面

共享资源
串行访问

临界区
临界资源

互斥
原子性

执行流的切换

1如何看待锁
  锁本身就是一个共享资源，全局变量要是被保护的，锁是用来保护全局资源，锁的安全谁来保护？
  pthread_mutex_lock，pthread_mutex_unlock;加锁的过程必须是安全的！,加锁过程其实是原子的！
  如果申请成功，继续向后执行。如果申请暂时没有呢？执行流会怎么办？执行流会阻塞。trylock：非阻塞申请
  谁持有锁，谁进入临界区
线程1
线程2
线程3
如果线程1，申请锁成功，进入临界资源，正在访问临界资源，其它线程在做什么？？  阻塞等待
如果线程1，申请锁成功，进入临界资源，正在访问临界资源，我可不可以被切换呢？？绝对可以的！，其它线程不能进来
  当持有锁的线程被切走，是被抱着锁切走的，即便自己被切走了，其它线程依旧无法申请成功锁，也变变无法向后执行！
  直到我最终释放这个锁！
其它线程的角度，看待当前线程有锁的过程 ，就是原子的。
  对应其它线程而言，有意义的锁的状态，无非两种
  1申请锁前
  2释放锁后
  原子态，两态
未来，我们在使用锁的时候，一定要尽量保证临界区的粒度非常小！
加锁是程序员行为，必须做到要加都要加！

2如何理解加锁和解锁的本质:加锁的过程是原子的。
  swap或exchange指令,该指令的作用是把寄存器和内存单元的数据相交换 ,由于只有一条指令.

mutex_t 锁变量
lock:
  movb $0, %a1  //a1是寄存器  0--》a1(0放到寄存器)（0放到上下文）。
  xchgb %a1, mutex // 交换的本质：共享的数据，交换到我的上下文。
  if(al寄存器的内容 > 0)
  {
    return 0
  }
  else
  {
    挂起等待
    goto lock;
  }

unlock
  movb $1, mutex
  唤醒等待Mutex的线程
  return 0;
1cpu内寄存器只有一套被所有执行流共享
2cpu内寄存器的内容，是每个执行流私有的，运行时的上下文。

3如果我们想简单的使用，该如何进行封装设计
  做一个设计
