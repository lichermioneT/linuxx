原生线程库
线程id，线程库结构体对象的id
线程栈--库里面

共享资源
串行访问

临界区
临界资源

互斥
原子性

执行流的切换

1如何看待锁
  锁本身就是一个共享资源，全局变量要是被保护的，锁是用来保护全局资源，锁的安全谁来保护？
  pthread_mutex_lock，pthread_mutex_unlock;加锁的过程必须是安全的！,加锁过程其实是原子的！
  如果申请成功，继续向后执行。如果申请暂时没有呢？执行流会怎么办？执行流会阻塞。trylock：非阻塞申请
  谁持有锁，谁进入临界区

线程1
线程2
线程3
如果线程1，申请锁成功，进入临界资源，正在访问临界资源，其它线程在做什么？？  阻塞等待
如果线程1，申请锁成功，进入临界资源，正在访问临界资源，我可不可以被切换呢？？绝对可以的！，其它线程不能进来
  当持有锁的线程被切走，是被抱着锁切走的，即便自己被切走了，其它线程依旧无法申请成功锁，也变变无法向后执行！
  直到我最终释放这个锁！
其它线程的角度，看待当前线程有锁的过程 ，就是原子的。
  对应其它线程而言，有意义的锁的状态，无非两种

  1申请锁前
  2释放锁后

  原子态，两态
未来，我们在使用锁的时候，一定要尽量保证临界区的粒度非常小！
加锁是程序员行为，必须做到要加都要加！

2如何理解加锁和解锁的本质:加锁的过程是原子的。
  swap或exchange指令,该指令的作用是把寄存器和内存单元的数据相交换 ,由于只有一条指令.

mutex_t 锁变量
lock:
  movb $0, %a1  //a1是寄存器  0--》a1(0放到寄存器)（0放到上下文）。
  xchgb %a1, mutex // 交换的本质：共享的数据，交换到我的上下文。
  if(al寄存器的内容 > 0)
  {
    return 0
  }
  else
  {
    挂起等待
    goto lock;
  }
unlock
  movb $1, mutex
  唤醒等待Mutex的线程
  return 0;
1cpu内寄存器只有一套被所有执行流共享
2cpu内寄存器的内容，是每个执行流私有的，运行时的上下文。


3如果我们想简单的使用，该如何进行封装设计
  做一个设计

可重入函数。
线程的安全。


死锁的概念。
a:0.5
b:0.5

谈谈死锁：在多把锁的场景下，我们持有自己的锁不释放，还要对方的锁，对方也是如此。

1.一把锁可能死锁吗? 一把锁把自己锁了两次。
2.为什么会有死锁？逻辑链条
  一定是你用了锁--》为什么你要用锁呢？---》保证临界资源的安全---》多线程访问我们可能出现数据不一致的问题---》多线程&&全局资源---》多线程大部分资源 全局的 共享的---》多线程的特性
  任何技术都有自己的边界，是解决问题的，但可能在解决的同时，一定可能会引入新的问题！

死锁的四个必要条件！
  互斥
  请求与保持
  不剥夺
  环路等待条件
互斥条件：一个资源每次只能被一个执行流使用
请求与保持条件：一个执行流因请求资源而阻塞时，对已获得的资源保持不放
不剥夺条件:一个执行流已获得的资源，在末使用完之前，不能强行剥夺
循环等待条件:若干执行流之间形成一种头尾相接的循环等待资源的关系

能不用锁，就不用锁。除非不得已啊。

线程同步问题
  
同步：在保证数据安全的前提下，让线程能够按照某种特定的顺序访问临界资源，从而有效避免饥饿问
题，叫做同步