gdb
冯诺依曼体系

输入设备 ---存储器-----输出设备
              |
              |
              |
             CPU

CPU只和内存打交道。
数据的写入写出都要经过内存。

硬件和软件高度配合的。
读 输入-----内存----CUP
写 CPU------内存----输出

CPU只能被动接收数据，指令。
  CPU已经内置了指令。
  二进制可执行程序---CUP认识的指令
  控制CPU执行的

OS(操作系统)
  OS是一个进行软，硬件资源管理的软件。
  OS对下软硬件资源
  OS对上为用户提供良好的执行环境。

管理的本质就是：先描述，后组织。
  管理者和被管理者不一定要接触.
  管理的本质就是管理数据。

  执行者：1被管理者的数据交给管理者 2执行指令 

  用户
  用户接口
  系统接口
  os
  驱动层
  硬件

先描述数据：结构体
后组织数据：数据结构

OS维护一个数据结构-----维护对应的对象
c语言--struct
c++----class

OS不相信任何人。

进程---操作系统里面的数据只能通过系统接口访问
什么是进程？
  程序就是一段二进制代码,就是一个文件 

描述进程的PCB
管理每一个PCB，用数据结构组织起来。

程序加载带内存，操作系统瞬间创建一个PCB
PCB里面有进程的所有信息。 描述进程的全部信息。

进程 == 内核数据结构 + 进程对应的磁盘代码

PCB(linux task_struct)

pid_t getpid()
pid_t getppid()
ps axj
ps aux
fork()
echo $$
ps $$

fork()之后，会有子进程+父进程两个进程在执行后续的代码
fork()后续的代码，让父子进程共享
通过返回值不同，让父子进程执行共享代码的一部分

进程状态
  1.运行
  2.新建
  3.就绪
  4.挂起
  5.阻塞
  6.等待
  7.停止
  8.挂机
  9.死亡
都是操作系统的说法
1.一般的操作系统怎么说
  a.搭建操作系统的宏观概念
  struct dev_keyboard{} struct dev_display{}   struct dev_net{}  struct dev_discard{}   struct dev_disk{}
  操作系统的运行队列
  cpu虽然很笨
  cpu但是很快
  外部设备很慢(进程或多或少都要访问)
  cpu---> struct runqueue{
        task1;
        task2;
        .....;
  };

  conclusion:
  一个CPU一个运行队列
  让进程如队列，本质：将该进程的task_struct放到队列里面。让PCB排队。
  PCB在运行队列当中就是运行状态，不是这个进程正在在运行才是运行状态。状态就是PCB里面的一个属性。进程所有的属性都在PCB里面放
  不要只意味着，你的进程只会等待(占用)CPU的资源，你的进程，也可能随时随地，要外设资源。 
  所谓进程的不同状态，本质是进程在不同的队列当中等待不同的资源。

  R状态，阻塞状态都是PCB对象放到不同的队列里。
  挂起状态--》

  挂起状态：内核数据结构还在的。code和data在磁盘里面。
  阻塞--不会立即执行--不会立即调度--等待很长时间---内存空间不够了怎么办？------>代码和数据暂时保存到磁盘上。(标识好。)  节省了一部分空间。
  将进程的相关数据，加载或者保存到磁盘-----》内存数据的换人换出。
  
  阻塞：阻塞不一定挂起
  挂起：挂起一定阻塞
  阻塞挂起状态：

进程队列
阻塞队列

  什么叫做运行：运行队列里面 等待执行
  什么叫做阻塞：阻塞队列里面 等待外设
  什么叫做挂起：数据放在磁盘 内存不足 PCB还在，code和data在磁盘

CPU--内存--外设
并不是一个量级的

2.Linux是怎么做的
  r运行状态
  s阻塞状态(linux是sleeping)  可以被终止的
  t状态 暂停
  d(disk sleep)深度睡眠   
  d()不可以被操作系统杀死的状态,只能通过断电或者进程自己醒来。
  d状态一般是高io状态，

状态后面带+前台进程
状态后面不带+后台进程

kill -9  id
kill -18 id
kill -19 id

宕机了

子进程被杀死了，就是僵尸状态，然后等待父进程回收他的数据和资源
