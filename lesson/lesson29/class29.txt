预备工作  信号的发送 信号的保存 信号的抵达处理
今天保存和抵达
task_struct
{ 
  // pending位图
  unsigned int pending = 0;  // 0000 0000  0000 0000  0000 0000  0000 0000 1.比特位的位置，信号编号。2.比特位的内容，是否，收到了对应的信号
  // block位图
  unsigned int block = 0;    // 0000 0000  0000 0000  0000 0000  0000 0000 2.比特位的位置，信号编号。2.比特位的内容，是否，阻塞了对应的信号
  hander_t hander[32];      //  函数指针数组，a数组的位置(下标)，信号的编号，b数组下标对应的内容，表示对应信号的处理方法
}

发生信号的载体只能是OS，OS才有权利修改PCB

// 信号抵达的伪代码
if((1<<(signo)-1) && pcb->block)
{
  //signo信号是被阻塞，不抵达
}
else 
{
  if((1<<(signo-1)) && pcb->pending)
  {
    // 信号抵达
  }
}

typedef void(*header_t)(int signo) // 函数指针
hander_t hander[32] = {0};         // 函数指针数组

1.数组下标，信号的标号
2.数组下标对应的内容，表示对应信号的处理方法
-----------------------------------------------------在内核中，信号的基本数据结构构成
signal(signo, hander); // 信号，处理方法给hander_t数组

如果一个信号没有产生，并不妨碍它可以先被阻塞
进程为何能够识别信号呢？PCB里面有信号的信息，进程已经认识了。

今日重点: 信号的捕捉流程!!
 信号产生的时候，不会立即处理，而是在合适的时候。从内核态返回用户态的时候，进行处理。 
 内核态：
 用户态：

OS是一个软硬件管理的软件
用户态的：-》1.操作系统自身的资源(getpid(), waitpid()) 2.硬件资源(printf(), read(), write())
为了用户访问内核或者硬件资源，必须通过系统调用完成访问。 printf() 底层还是访问操作系统的接口, 访问硬件：显示器。 io/内存

内核态:用户态变成用户态的时候，调用系统调用。实际执行系统调用的进程，但身份其实是内核。 往往系统调用比较费时间。尽量避免频繁调用系统调用。
1.可见寄存器 : 
2.不可见寄存器 : 
凡是和当前进程强相关的，上下文数据。

寄存器：pcb
寄存器：页表起始地址
CR3:0内核态，3用户态

我一直不太理解：我是一个进程，怎么跑到OS中执行方法呢？ 用户空间！
  task_struct{} 曾经都是用户空间  用户级别页表， 每个用户都有自己独立的用户级别页表
  
  内核级页表 内核级页表只需要有一份就够了  访问OS
  每一个进程都有自己的地址空间(用户空间独占)， 内核空间（被映射到每一个进程3-4G)  进程要访问OS的接口，其实只需在自己的地址空间上跳转就可以了？
  每个进程都有3-4g，都会共享一个内核级页表，无论进程如何切换，不会更改任何的3-4g
  用户，凭什么能够访问内核的接口或者数据呢？ CR3寄存器，0内核态，3用户态。 
  系统调用接口，起始位置会帮你做的！ Int 80 陷入内核。3--0
  
信号产生的时候，不会立即处理，而是在合适的时候。从内核态返回用户态的时候，进行处理。 
  曾经我们一定是先进入内核态！ 系统调用，进程切换，

用户态
      
内核态
    block pending hander_t
    // 默认 忽略 自定义
    // 
    我们能不能以内核态的身份执行用户态？ 不能的！！ OS不相信任何人！！ 万一执行 sudo rm -rf /*
    恶意利用内核态的身份执行其它指令，很危险
    特定的调用，将自己的身份切换成用户态    用户态被监管起来了的！
    反过来呢？不能

无穷大


block 信号品

1默认情况下：我们的所有信号都是不被阻塞的
2默认情况下：如果一个信号被屏蔽了，改信号不会抵达

1.信号的保存
2.信号的抵达 捕捉 倒着的无穷大
3.地址空间无穷大
4.用户态内核态
5.3-4g内核级别地址空间

