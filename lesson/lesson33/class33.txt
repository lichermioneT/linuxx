线程是可以等待的，等待的时候，join等待，阻塞式等待，如果我们不想等待呢？
  
原生线程库，可能要存在多个线程--你用这些接口创建了线程，别人也可以同时在用的
  原生线程库，要不要对线程管理呢？ 要！
先描述：线程的属性比较少，
在组织：

Linux方案：用户级别线程，用户关心的线程属性在库中，内核提供线程执行流的调度
Linux用户级线程：内核轻量级进程=1；1

用户级线程id究竟是什么？
就是库里面创建的结构体对象
id就是结构体对象的地址

用户级线程id究竟是什么？
共享区

线程局部存储__thread 修饰属性

pthread库就是磁盘的一个文件
1.

共享资源
ticket只剩最后一张了
判断的本质：1读取内存的数据到CPU里面，2进行判断

ticket
ticket--
1.
进程1进来了，睡觉了，上下文切换，ticket>0
进程2进来了，睡觉了，上下文切换，ticket>0
进程3进来了，睡觉了，上下文切换，ticket>0
进程4进来了，睡觉了，上下文切换，ticket>0
2.
进程1醒了，读数据ticket = 1
进程2醒了，读数据ticket = -1
进程3醒了，读数据ticket = -2


std::cout<< user_name << "真正抢票 " << tickets--<<std::endl;
1.thread1 读10000
2.thread1 1000->999  // 还没有写的内存，被调度走了
  thread2 读1000
  thread2 1000->999
  thread2 写999
3.thread2 写999

极端thread执行100次后，被调度走了
thread2,写999，(乱了)

一条c/c++代码转汇编
1.内存--》CPU的寄存器
2.寄存器在cpu进行对应的逻辑运行
3.重新写回结果到内存中

我们定义的全局变量，没有保护的时候，往往是不安全的，像上面多个线程在交替执行，造成的数据安全问题，数据不一致问题。
多个执行流进行，安全访问的共享资源--临界资源    （小部分的代码）
我们把多个执行流中，访问临界资源的代码，临界区  （小部分的代码） 往往是线程代码的很小一部分
想让多个线程，串行访问共享资源--互斥
对一个资源进行访问的时候，要么不做，要么做完---原子性，（解释不是原子性的场景）(刚才的123，三条汇编语句)--一个对资源进行操作，如果只用一条汇编就能完成，原子性操作。反之不是原子的。 
反之：不是原子的，当前理解，方便表述。

解决方案：加锁