线程同步：按照顺序访问资源。
加锁：xchag
死锁

条件变量
生产消费模型


生产消费模型
 生产者消费者模型

学生--消费者   超市共享资源   供货商--生产者
超市：集中需求，分发产品。交易场所。

因为超市存在，生产和消费不相互干扰。解耦。
临时的保存产品的场所。--缓冲区
共享资源必须被保护起来


函数调用！反例
调用方：生产了数据
形成变量：变量暂时保存数据
目标函数：消费数据
main-->fun:main函数等fun函数，强耦合关系
改：生产消费
mian函数的数据放到缓冲区
调用fun函数,fun执行，打印结果

生产消费模型：
  生产者和生产者之间：互斥关系 资源放谁的
  消费者和消费者之间：互斥关系 谁能够拿到
  生产者和消费者之间：互斥关系&&同步关系 数据安全性

总结："321"
3种关系：生产者和生产者：互斥，消费者和消费者：互斥，生产者和消费者:互斥和同步 产品数据
2种角色：生产者线程，消费者线程
1一个交易场所：一段特定结构的缓冲区
写生产者消费模型，本质就是维护321原则

生产消费者模型特点：
1.未来生产线程和消费线程解耦
2.支持生产和消费的一段时间的忙闲不均的问题
3.提高效率 体现在哪里呢？ 

生产者：加锁，判断还需不需要商品，然后，解锁。 循环。死锁

条件变量
临界资源
加锁
判断---生产和消费条件是否满足
(条件不满足，就不要再申请，而是将自己挂起！)
解锁


理解条件变量
1.一个例子
  条件变量：
  当条件不满足的时候，我们线程必须去某些定义好的条件变量上等待
2.一张图

struct cond
{
  int status;
  task_struct* q;
}

task_struct
t1--t2--t3--t4

int = pthread_cond_init()
int = pthread_destory()
int = 
