网络协议栈
应用层：套接字,序列，
传输层: UDP/TCP
网络层: 
数据链路层

传输层
负责数据能够从发送端传输接收端

在谈端口号 port
"源IP", "源端口号", "目的IP", "目的端口号"
IP标定主机，port标定服务不同。
协议号，用什么协议拉进行通信。

五元组标识一组通信。

端口号范围划分
知名端口0-1023. 端口号是固定作用的。
1024-65535，随意绑定的。
ssh:22
ftp:21

一个端口bind多个进程
端口号   进程(自底向上交付)  唯一关系。

一个进程bind多个端口 
端口号   进程(自底向上交付)  唯一关系。
端口号在传输层。

指令
netstat
pidof：pidof 进程名称
pidof 进程名称 | xargs kill - 9

UDP协议格式。
1.学习所有的协议，报头和效载荷
2.如何进行解包，如何进行分用。
    解包：回答一个问题，如何将报头和有效载荷进行分离。
    分用：如何交付给上层进程。

UDP协议格式。
16位源端口号 16位目的端口号 
16UDP长度    16位UDP校验和
    数据(如果有)

固定报头。
udp固定报头。

理解udp报头。
理解：
linux内核是用c语言写的！
（报头，OS层面定制的协议。）
所以所谓的报头其实就是一种结构化数据对象
struct udp_hdr{
    uint16_t src_port,
    uint16_t dsc_port,
    uint16_t length,
    uint16_t check,
}

应用层 send(你好)
---
OS   （拷贝数据：你好） 报头+数据 
协议就是结构体或者位段。

无连接: 知道对端的IP和端口号就直接进行传输, 不需要建立连接;
不可靠: 没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息
    不可靠，丢了就丢了
面向数据报: 不能够灵活的控制读写数据的次数和数量;
    整发整取
    sendto100次----recvfrom100次
    只需要反序列化
面向数据报（Datagram-Oriented）是一种网络通信方式，其核心特征是数据以独立、自包含的报文（Datagram） 为单位进行传输。
每个报文都携带完整的源地址、目标地址和传输数据，传输过程中不建立持久的连接，也不保证顺序和可靠性。

TCP发送10次20次40次
TCP接收13次21次12次
应用层自己定制协议，接收完整。

UDP没有真正意义上的缓冲区
应用层： 
传输层：
网络层：
数据链路层： 

TCP
我们用的网络IO接口，其实并不是直接发送和接收接口，而是拷贝接口！

client
send/write-->发送缓冲区--->OS--->网络--->接收缓冲区--->read/recv-->server
发送接收
接收发送

缓冲区
1.支持全双工
2.节约时间，引用层的时间
3.OS和TCP协议控制


UDP:
UDP没有真正意义上的 发送缓冲区. 调用sendto会直接交给内核, 由内核将数据传给网络层协议进行后
续的传输动作
UDP具有接收缓冲区. 但是这个接收缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致; 如果
缓冲区满了, 再到达的UDP数据就会被丢弃;


NFS: 网络文件系统
TFTP: 简单文件传输协议
DHCP: 动态主机配置协议
BOOTP: 启动协议(用于无盘设备启动)
DNS: 域名解析协议


TCP协议
1.认识TCP协议的报头--字段
    16源端口 16位目的端口号：哪儿来，去哪儿。
    32位序号 
    32位确认序号
    4位首部长度 保留6位 xxxx 16位窗口大小
    16位校验和  16位紧急指针

共20字节。
2.如何封装解包，如何分用
    解包
    a.tcp协议是有标准长度的：20，先读取20再说。
    b.转换成为一个结构化的数据，立马提取标准报头中的4位首部长度
        4位首部长度：TCP报头的总长度。【0-15】
        tcp报文的总长度=4位首部长度*4字节。【0-60】【20-60】
        如果我们报头就是20字节，那么4位首部长度，应该填写多少呢？
    c.后续报头的剩余大小。x*4-20=?
    d.只要把tcp报头处理读取完毕，剩下的不就是有效载荷吗？
    问题：tcp的报头里面，没有有效载荷的长度！为什么。

    分用
    1.目的端口号呢。就可以找到应用层的进程了，数据就可以交付给进程。    
理解：  
我们收到一个报文，是如何找到曾经bind特定port的进程的，网络协议栈和文件是什么关系？
系统有很多的场景，需要我们快速定位一个进程。
port--》 hash--》PCB.
通过port找到进程的PCB.
PCB-->文件描述符。
写到文件缓冲区里面。

3.如何理解TCP的报头
    就是一个结构体。
    报头 + 数据 

4.学习TCP可靠性(确认应答)&&传输高效率
a.为什么网络传输的时候，会存在不可靠问题？
    内存和外设用线 IO总线。
    内存和CUP链接的时候，也是用“线”，系统总线。
    内存和外设之间通信，也有自己的协议---外设控制---嵌入式。
        可靠性问题？距离很近。
    
b.不可靠问题常见都是那些不可靠的场景？
    丢包，乱序，校验错误，重复，

c.tcp的可靠性怎么保证？切入点
    如果距离长了，存不存在绝对的可靠性？？收到应答。
    A----B 
    1.A你吃了吗
    2.B我吃了
    3.A那我们一起玩耍吧。
    1.我们认为，只有收到应答，历史消息我们才能百分之百确认对方收到---确认应答了，才是可靠
    2.双方通信，一定存在最新的数据，没有应道！最新的消息一般无法保证可靠性。

    存在相对的可靠性
    一个报文只要收到了应答
    就能保证该报文的可靠性

