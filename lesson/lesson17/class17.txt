进程创建
  创建PCB，地址空间，页表，映射，进程代码和数据load到内存里面。

进程退出
  释放资源，变成僵尸，父进程读取

退出exit和_exit
用户级别的缓冲区

进程等待

从退出进程的tast_struct中获取。
1.进程退出会变成僵尸，会把自己的退出结果写入到自己的task_struct
2.wait和waitpid是一个系统调用，os os有资格也有能力去读取子进程的task_struct


阻塞
非阻塞

1.不挂电话,一直检测李四的状态
2.张三-->李四 本质检测状态， 如果没就绪，就直接返回。每一次都是一次非阻塞等待。多次非阻塞等待就是--轮询

非阻塞等待好处？不会占用父进程的所有精力，可以轮询期间干干别的！
阻塞等待

进程等待
释放子进程的资源
获取子进程的退出码


进程替换
1.创建子进程的目的
  让子进程执行父进程的一部分。执行父进程对应磁盘代码中的一部分。
  让子进程执行一个全新的程序，让我们的子进程想办法，加载磁盘上指定的程序，执行新程序的代码和数据。


int execl(const char *path, const char *arg0, ..., (char *) NULL);  将程序加载到内存里面，让指定进程去进行执行
          
程序替换的本质就是，将指定的程序代码和数据加载到指定的位置，(指定的位置,覆盖自己的数据和代码)；
  进程替换没有创建新的进程。

虚拟地址空间 + 页表 == 保证进程的独立性

exec
l:list
p:path,如何找到程序的功能
v:vector,

waitpid(id,&status,0)
waitpid(id,&status,WNOHONG)


