共享内存
  理解新的知识概念
  进程间通信，不同进程看到不同的内存。这理解是key
  shmid用户层面使用的
  key系统层面
  共享内存不仅仅是给你用，还需要管理 共享内存 = 内存 + 数据结构
  生命周期随内核 删除指令和函数
  通信速度最快的
  没有加安全保证的


struct text
{
  int type;
  char buffer[];
}


信号量
信号量是什么？本质是一个计数器，通常用来表示公共资源数量的多少问题。
公共资源：被多个进程同时可以访问的资源。
访问没有保护的公共资源的时候；数据不一致的问题。
  
让不同的进程看到同一份资源呢？因为我想通信，进程间实现协同--》进程独立性--》需要让进程看到同一份资源--》提出方法，引进新的问题！（数据不一致的问题）
我们未来将被保护起来的公共资源：临界资源，有大部分的资源是独立的，
资源（内存，网络，文件）是要被使用的，如何被进程使用呢？一定是该进程有对应的代码来访问这部分资源：临界区  非临界区

保护策略：互斥和同步
要么不做，要么做完，两态的这种情况：原子性

我为什么需要信号量？
共享资源：1作为一个整体使用，2划分成为一个一个的资源子部分
进程访问资源子部分---》先访问信号量---》---》成功就有权访问资源子部分----------》信号量

sem = 20
sem--:预定资源 所有的进程在访问公共资源之前，都必须先申请sem信号量-》申请信号量的前提是，先看到同一个信号量--》信号量本身就是公共资源。--》信号量也要保证自己的安全》信号量保证自身的安全
--，++操作是原子的()
访问公共资源
sme++:释放资源
p--,v++.pv操作就是原子操作
信号量 1是就是互斥信号量，二元信号量


预定
匹配操作

IPC资源的组织方式。

struct ipc_perm* perms[]

c语言实现c++的多态。


信号
整个信号的生命周期 
预备
信号产生
信号保存
信号处理

1-31:普通信号
34-64:实时信号



识别信号
产生信号
1能够识别信号
2信号到来的时候，我们不一定马上处理这个信号
 信号可以随时产生（异步），我们可能做着更重要的事情
3信号到来-------时间窗口（必须记住这个信号）---------信号被处理
4默认动作，自定义动作，忽略动作，


1信号是给进程发送的
  进程是如何识别信号的 == 认识 + 动作
  进程本身是程序员编写的属性和逻辑的集合---程序员编码完成的
  进程收到信号的时候，可能正在执行更重要的代码，进程不一定会被立即执行的
  进行本身要有对于信号的保存能力
  进行在处理信号的时候：1.默认动作2.自定义动作3.忽略【信号被捕捉】
  
如果一个信号是发送给进行的，而进程要保存，那么应该保存在哪里呢，PCB里面，task_struct里面
如何保存呢？是否收到了指定信号【1,31】
struct task_struct
{
  unsigned int signal;
  0000 0000 0000 0000 0000 0000 0000 0000
  比特位的内容代表是否收到内容，0无，1有
}

如何理解信号的发送？
  发送信号的本质；就是修改PCB的信号位图。

PCB内核维护的数据结构对象，PCB的管理者是OS,只有OS有权利修改PCB
  未来我们学习多少种发送信号的方式，本质上都是通过OS向目标进程发送信号
  os提供 发送处理信号的相关系统调用
  kill---底层调用了对应的系统调用。


信号如何产生！
  
ctrl + c 2号信号 SIGINT














































































