TCP定制协议：就是让TCP，发送和接收消息不乱来的
TCP
服务端
close 
listen:获取连接 
syn_rcvd:
established

客户端
close
syn_sent:发起请求(connect()) 这里面存在三次握手。OS自动完成的。OS自动完成的。OS自动完成的。OS自动完成的。
established

三次握手
1.  **A打给B**：“喂，你好，能听到吗？我的号码是X。”（第一次握手）
2.  **B回答A**：“听到了，我能听到你。我的号码是Y。你的号码是X，对吧？”（第二次握手）
3.  **A再确认**：“对的，我的号码就是X，我也能听到你。”（第三次握手）
—— 至此，双方都确认了通信渠道畅通，可以开始正式谈话。
四次挥手
记住这个流程： SYN -> SYN-ACK -> ACK。这就是TCP三次握手的精髓。
记住这个流程： FIN -> ACK -> FIN -> ACK。以及两个关键点：半关闭和主动关闭方的 TIME_WAIT。

建立链接需要先描述，然后组织起来的。
链接OS完成的，需要花时间的。断开链接四次挥手。
建立链接双方协商，断开链接双方协商。

Uniform Resource Locator
URL
（统一资源定位符）

HTTP = HyperText Transfer Protocol
（超文本传输协议）


再谈协议
什么是协议：约定

传输一个结构化的数据呢
头像url,时间，昵称，消息---》打包变成一个报文，方便我们就那些整体发送。
多变一：序列化的过程。
网络发送
收到一个报文，反序列化
头像url,时间，昵称，消息
结论：业务结构数据在发送到网络中的时候，先序列化在发送，
收到的一定是序列字节流，要先进行反序列化，然后才能使用

结构化数据进行建模 业务协议
class/struct message
{
  string url;
  string time;
  string nickname;
  string
  msg;
};
TCP这里，你怎么保存你收到一个完整的报文？


我们自己手写一个
TCP是面向字节流的，明确报文和报文的边界。
TCP有自己的发送缓冲区，接收缓冲区。

应用层 (应用层缓冲区)
TCP层 (之间就是套接字)
  我们调用的所有的发送函数，根本就不是把数据发送到网络中！
  发送函数，本质是拷贝函数！(TCP协议自己决定什么时候发送)
  接收函数，本质是拷贝函数！(TCP协议自己决定什么时候接收)
  传输控制协议
s-c:TCP发送的本质, 其实就是将数据从s的发送缓冲区，拷贝到c的接收缓冲区。
c-s:TCP发送的本质, 其实就是将数据从c的发送缓冲区，拷贝到s的接收缓冲区。
所以TCP是全双工的。(接收和发送的缓冲区分开的)
来不及缓冲区太多的数据了。如何解决
  1.定长
  2.特殊符号
  3.自描述方式 [4字节特殊符号，数据的长度][真实数据]

  