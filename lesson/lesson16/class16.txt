fork

1.两个值

用户空间:fork()
内核空间:

pid_t fork()
{
  创建子进程PCB
  赋值
  创建子进程的地址空间
  赋值
  创建并设置页表
  子进程放入进程list
  return pid; (return之前子进程已经创建好了的)

  父进程和子进程各字执行return。
}


2.
给父进程返回子进程的id
给子进程返回0
唯一性

3.

环境变量
  系统层面相关的信息。
  环境变量具有全局属性

命令行参数
  c/c++的两个表，命令行参数表 ，环境变量表
  环境变量的获取 getenv,env,**environ
  echo

进程地址空间
  虚拟地址---------页表----------物理地址
  fork证明这不是实际的物理地址
  
  进程认为自己独享内存。进程虚拟地址空间。
  地址空间的本质，内核空间的一种数据结构。mm_struct
  范围2^32

进程地址空间内核的数据结构

task_struct *mm process address 页表  物理地址

程序编译好已经存在地址了。就是虚拟地址。
*mm的数据来自程序。


写时拷贝

进程退出

返回值
echo $?
?是shell的一个变量，永远记录最近一个进程的退出码，main--->return

进程退出码的三种情况
1代码跑完了，结构正确    return 0
2代码跑完了，结果不正确  return !0
3代码没有跑完，直接崩了 退出码没有意义。
  
进程如何退出呢？
  1mian函数返回
  2exit函数
  3_exit函数

exit和_exit区别
exit 库函数
_exit系统调用

exit终止进程，他会主动刷新缓存区
_exit终止进程，他不会主动刷新缓存区

库函数            exit()----c
系统掉用接口     _exit()----OS
操作系统          

exit就是通过_exit终止进程的。
缓冲区在在哪里呢？用户级的缓冲区。

进程退出

进程等待
回收子进程的资源，获取子进程的退出信息。
僵尸状态
z状态
退出码，判断进程的退出的原因。

子进程退出的
exit_code:
signal:

waitpid(id, &status, 0);
检查子进程的退出信息，并且将子进程退出信息通过status拿回来。

