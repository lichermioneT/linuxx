char* str = "hello world"
*str = "h"

如何看待页表？
1.地址空间是进程能看到的资源窗口
2.页表决定进程真正拥有资源的情况
3.合理的对地址空间+页表进行资源划分，我们就可以对一个进程所有的资源进行分类

页表：虚拟地址--》物理地址
虚拟地址空间2^23
虚拟地址：0000 0000 0000 0000 0000 0000 0000 0000  

stuct Page
{
  // 内存的属性--4kb
}

物理内存分块----页框
struct Page mem[] // 物理内存管理起来

页帧(编译完成的代码)(4kb为单位的)
管理算法,伙伴系统

1-10    11-20 21-32
页目录  页表  12位的偏移地址


复习
可重入函数
volate关键词，保持内存可见性
sigchild sigign

内存划分：4kb(pages)
code:4kb为单位
虚拟---》物理 10 10 12
10:页目录
10:页表



-------------------------------
线程

进程 = 内核数据结构 + 进程对应的代码和数据
线程：进程内的一个执行流。(一般定义)
1.OS都太宏观了，太抽象了。
2.具体化，Linux


如何看待虚拟内存？虚拟内存里面决定了进程能够看待的"资源" 主体资源，
task1----mm_struct
task2----mm_struct
task3----mm_struct
task4----mm_struct

只是创建PCB(进程控制块) 通过mm_struct看到同一块资源
因为通过虚拟地址空间+页表的方式进行进程的资源划分，单个"进程"的执行 力度，一定比之前的进程细

OS真的存在，那么应该如何管理起来呢？怎么管理？先描述，后组织。
  CPU只关注指令，不关注你是进程还是线程。

描述：一定要为线程设计专门的数据结构，表示线程对象。TCB(thread control block) 线程控制块。(windows，单独的线程块) (Linux, 复用PCB-->TCB)
      线程被执行：调度(id, 状态， 优先级， 上下文，栈) 单纯调度的时候，进程和线程有很多地方是重叠的。
      linux工程师，我们不想给Linux线程专门设计数据机构，直接复用线程PCB， 用PCB来标识Linux内部的线程
组织：

1.线程在进程内部运行，线程在进程地址空间内运行，有地址空间的一部分数据。

进程 = 内核数据结构 + 进程的数据和代码
进程的新概念：内核 ： 承担分配系统资源的基本实体。
在linux中，线程，CPU调度的基本单位
一个进程内部的执行流！----》线程。

task_struct轻量级进程！


linux内核中有没有真正意义上的线程？严格意义上没得，Linux使用进程PCB来模拟线程的，是一套完全属于自己的一套线程方案。
cpu的视角，每一个PCB都是轻量级进程。
linux线程是CPU调度的基本单位，而进程是承担分配系统资源的基本单位
进程用来申请资源，线程用来伸手向进程要资源。

好处：
  简单，维护成本大大降低---可靠，高效！
缺点：
  linux无法直接提供创建线程的系统调用接口，而只能给我们提供轻量级进程的接口！ 
  -lpthread 线程的库

  用户
  用户级别线程库--->原生线程库
  OS

如何理解？
  家庭：进程
  家庭成员：线程
如何证明？
  写代码
  新线程可以共享很多
  方法，变量
  线程间通信那简直就是很简单的！！！
  线程一旦被创建，几乎所有的资源都是被所有线程共享的！
  线程也一定要有自己的私有属性内容！什么资源是私有的呢？
  1.pcb里面的属性
  2.线程切换，上下文
  3.每一个线程都要有自己独立的栈结构
如何操作？



LWP:light weight process:轻量级进程
[root@lic lesson31]# ps -aL
  PID   LWP TTY          TIME CMD
22971 22971 pts/0    00:00:00 mythread  主线程
22971 22972 pts/0    00:00:00 mythread
23155 23155 pts/1    00:00:00 ps

CPU调度的时候，LWP表示一个特定的执行流的！
以前理解的时候是 PID=LWP 单进程的时候 PID和LWD等价的！

与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多
少呢些？：
切换页表
虚拟地址空间
------------
切换PCB
上下文
cache切换不用太更新，进程切换全部更新

cpu的cache：硬件级别的缓存，局部性原理。先从cache里面读取。cache里面缓冲很多热点数据。线程的共享数据基本上都在cache里面。cache基本上不用切换的。进程切换，cache全部切换。

计算密集型 CPU资源
IO密集型   访问磁盘 显示 器网络
