# BIT.10_网络编程套接字.pdf



## 1理解源IP地址和目的IP地址和端口号

**网络编程套接字**

**源  ip地址：发送端:从哪儿来**

**目的ip地址：接受端:到哪儿去**

**从哪儿来--到哪儿去**



**IPA          ....路由器....            IPB**



![image-20251217095440194](picture/image-20251217095440194.png)



**我们把数据从A主机送到B主机是目的吗？不是**

**真正通信的，不是这两个机器！**

**其实这两台机器上面的软件(人)**



**数据有IP(公网IP)标识一台唯一的主机**

**用谁来标识各: 主机上客户或者服务进程的唯一性呢？**

**为了更好的表示一台主机上服务进程的唯一性，我们采用端口号port，标识服务器进程，客户进程的唯一性。**

**1.ip地址(主机全网唯一性) + 该主机上的端口号，标识该服务器上进程的唯一性。**

​	**ipA + portA,  ipB + portB**

​	**A该主机上对应的服务进程，在全网中是唯一的一个进程。ip + port。**

​	**B该主机上对应的服务进程，在全网中是唯一的一个进程。ip + port。**

**网络通信的本质：**

**网络通信的本质：其实就是进程间通信！！**



**服务端   网络   客户端**

**1.进程间通信，先让不同的进程看到同一份资源----网络**

**2.通信不就是在做IO吗？---- 所有我们所有的上网行为：无外乎两种：我要把我的数据发出去。我要收到别人发给我的数据。**



**2ip保证全网唯一（这里是公网IP），port保证在主机内部的唯一性。**



**3进程已经有了pid，为什么有还需要port呢？**

​    **1.系统是系统，网络是网络。单独设置---为了系统和网络解耦。**

​	**2.需要客户端每次都能找到服务器进程--服务器的唯一性不能做任何改变。IP+PORT不能随便改变的。不能随意改变。不能使用轻易会改变的值。 **

​	**3.不是所有的进程都需要提供网络服务或者请求，但是所有的进程都需要pid。这就是为什么不使用pid标定在网络中的唯一性。 **



**4进程 + port ---》网络服务进程 **

**底层OS如何根据port找到指定的进程---》uint16-->task_struct -->hash(基于端口号 key, value pcb地址) pcb 文件 文件缓冲区。**

**pcb可能是多个数据结构的 点。多种数据结构的组合点。**



**一个进程可以绑定多个端口号，但是一个端口号不能被多个进程绑定。**

**我们在网络通信的过程中，IP+PORT标识唯一性  client-->server。除了数据，需要把自己的ip和port发给对方吗？需要的，我们还要发回来 **

**未来发数据的时候，一定会  多发 一部分数据--以协议的形式呈现。**



**端口号是传输层协议的内容：**

​	**传输层的端口号。**

![image-20251217101115974](picture/image-20251217101115974.png)



## 2TCP和UDP

**传输层协议**

**TCP协议：TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议。**

​	**传输层协议**

​	**有连接**

​	**可靠传输**

**面向字节流：TCP 传输数据的时候，不关心消息（message）边界，只把所有数据当成一串连续的字节流来传输。**



**UDP协议：UDP 是一种无连接的、不可靠的传输层通信协议。**

​	**传输层协议**

​	**无连接**

​	**不可靠传输**

**面向数据报：面向数据报 = 有边界、每个消息独立传输，发送端的一个数据报对应接收端的一个数据报。**



**面向数据报（UDP）：每个包独立、有边界、不能被拆或合并，可能丢失、乱序、不可靠但速度快。**

**面向字节流（TCP）：数据无边界，是连续字节流，可能粘包、拆包，但可靠、顺序。**



**不可靠和可靠是中性词。**

**可靠是有成本的---这样的协议往往是复杂的---维护&&编码**

**不可靠-----------这样的协议往往比较简单---维护和使用**

**挑选合适的场景。**



## 3网络字节序

**发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出** **加加比较方便**

**c语言：小小小。小端。**

**网络字节序列**

**接受方，怎么知道是发送的数据是大小端？？**

**规定网络中的数据都是大端。**

**网络字节流：**

**发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出。++简单**



**网络字节序：网络字节序 = 规定使用大端字节序（Big-Endian）来表示多字节数据。**

**h: host主机**

**n: net网络**

**l: long 32字节**

**s: short 16字节**

**uint32_t htonl(uint32_t hostlong);**

**uint16_t htons(uint16_t hostshort);**

**uint32_t ntohl(uint32_t netlong);**

**uint16_t ntohs(uint16_t netshort);**



![image-20251217103256005](picture/image-20251217103256005.png)

**其它 的数据默认处理的**



## 4SOCKET编程接口

**IP + PORT  == 套接字(SOCKET)**



**1网络套接字编程：跨主机和网络**

**2原始套接字：**

**3Unix域间套接字：**

**三套不同的接口。只是设计一套接口，通过参数的不同，解决所有网络或者其他场景下的通信问题。**



**多态**

**struct sockadd**

**struct sockadd_in**

**struct sockadd_un**

**设计这一套c语言不支持void***

**操作系统级别的接口**



![image-20251217104348773](picture/image-20251217104348773.png)



## 5UDP编程

**网络数据流动：局域网和全局网**

**实际通行是主机的进程**

**ip+port标识唯一性。通过网络进行相互通信。**

**通信就是IO嘛。pid和需要port进行解耦。网络和OS进行解耦。**

**网络字节序。大端**

**socket接口**



```c++
struct sockaddr_in 
{
    sa_family_t    sin_family;   // 地址族（协议族）
    in_port_t      sin_port;     // 端口号（网络字节序）
    struct in_addr sin_addr;     // IP 地址
    unsigned char  sin_zero[8];  // 填充字节（对齐用）
};

```



**服务器端口必须是确定的。**

**服务器死循环，常驻内存进行。**













