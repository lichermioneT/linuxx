### 详细总结

这个文档（基于BIT.5_基础IO.pdf的笔记）主要讨论了Linux/C语言下的基础IO操作、文件系统原理、缓冲机制、链接类型以及静态/动态库的构建与使用。内容从文件的基本概念入手，逐步深入到系统调用、进程与文件的关系、缓冲区策略、文件系统的物理/逻辑结构，以及库文件的链接机制。整体强调文件操作的本质（进程与被打开文件的关系）、IO效率优化（如缓冲区）和模块化开发（如库）。下面按文档结构分节详细总结，每个节后附带关键代码示例（提取自文档，并标注位置）。总结力求全面、逻辑清晰，突出核心概念、原理和注意点。

#### 1. 重新谈论文件
这一节重新审视文件的基本属性和操作，强调文件=内容+属性，操作本质上是进程对被打开文件的关系。关键点：
- **文件特性**：空文件也占空间；文件路径+文件名确保唯一性；默认路径为进程当前路径；文件操作需通过`fopen/fclose/fread/fwrite`等接口，但这些仅在进程运行时生效（非编译时）。
- **打开与访问**：文件必须被进程打开才能访问（OS管理打开文件，未打开的文件在文件系统中）。所有语言（C、C++、Java等）最终通过OS系统调用（如`open/read/write`）访问磁盘。
- **C语言库函数 vs 系统调用**：库函数（如`fprintf`）封装系统调用（如`write`），底层不变，便于学习。模式包括`r`（读）、`w`（写，清空）、`a`（追加）、`r+/w+/a+`（读写）。
- **权限**：普通文件默认666，目录777。使用位图（bit flags）传递选项，如`O_WRONLY | O_CREAT`。
- **文件描述符（fd）**：从3开始（0=stdin,1=stdout,2=stderr）。进程打开多个文件，OS用`struct file{}`管理。
- **重定向**：本质是内核中更改fd指向的`struct file*`。使用`dup2(oldfd, newfd)`实现输入/输出/追加重定向。Shell实现需解析命令、fork子进程，并在子进程中处理重定向。
- **Shell简化实现**：支持内建命令（如`cd`、`echo $?`）、参数解析、ls美化、重定向（< > >>），使用`fork/execvp/waitpid`执行外部命令，记录退出码/信号。

**注意**：重定向不影响父进程；`umask(0)`忽略默认权限掩码；`fflush(stdout)`确保缓冲刷新。

#### 2. Linux一切皆文件
这一节引入“一切皆文件”哲学，强调多态性（文件可表示设备、管道等）。关键点：
- **多态**：文件统一接口处理磁盘、设备、网络等（进程地址空间、引用计数、存储/计算/业务抽象）。
- **文件管理**：OS为打开文件创建内核`struct file{}`，包含属性（如偏移、权限）。fd从3递增，`close(fd)`释放。

**注意**：这部分简短，过渡到缓冲区，强调文件操作的统一性。

#### 3. 缓冲区
缓冲区是用户空间内存，用于优化IO效率（减少直接磁盘访问）。关键点：
- **缓冲本质**：用户级（非内核），属于`FILE*`结构体（包含fd+缓冲区）。意义：空间换时间，批量IO（如快递缓存）。
- **刷新策略**：
  - 无缓冲（立即刷新）。
  - 行缓冲（`\n`触发，如stdout到显示器）。
  - 全缓冲（满载触发，如到磁盘）。
- **特例刷新**：用户`fflush(fp)`、进程退出`fclose(fp)`。fork()时，若缓冲未刷新，会拷贝数据导致重复输出（重定向到文件时更明显）。
- **C接口 vs 系统调用**：`printf/fprintf/fputs`用缓冲，`write`直接fd无缓冲。
- **模拟实现**：自定义`FILE_`结构体，支持`fopen_/fwrite_/fflush_/fclose_`，根据flags（SYNC_NOW/LINE/FULL）刷新。

**注意**：重定向到文件时，stdout从行缓冲变全缓冲；fork前未刷新会导致写时拷贝问题。

#### 4. 文件系统
这一节详解Linux ext2/ext3文件系统结构，强调磁盘物理到逻辑的映射。关键点：
- **磁盘物理**：磁道→盘面→扇区（512B）。OS逻辑块大小1-4KB（局部性原理：缓存4KB页框/页帧）。
- **文件分离存储**：内容（data block）+属性（inode）。目录内容是文件名→inode映射。
- **文件系统结构**（多块组）：
  - **Super Block**：全局元数据（块大小、总块/inode数、挂载时间等，有备份）。
  - **Group Descriptor Table (GDT)**：块组描述（bitmap/inode table位置、空闲计数）。
  - **Block Bitmap**：数据块占用（1=用，0=闲）。
  - **Inode Bitmap**：inode占用。
  - **Inode Table**：每个文件一个inode（id、mode、uid、size、blocks[15]指针，支持间接块）。
  - **Data Blocks**：文件/目录内容。
- **路径查找**：多叉树（/根），用inode号统一寻址。
- **链接**：
  - **硬链接**（`ln src link`）：增加inode引用计数（nlink++），无新内容/属性。删除当nlink=0。
  - **软链接**（`ln -s src link`）：路径字符串记录，源文件删则失效。`.`/`.`也为文件。
- **权限/复习**：开源生态、权限（人+操作）、粘滞位、进程控制、内建指令。

**注意**：inode不存文件名；分布式系统可扩展；文件删除检查nlink。

| 区域                                         | 作用                                                         | 关键点总结                                                   |
| -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Super Block**                              | 文件系统的“身份证”，保存整个文件系统的核心元数据             | 块大小、总块数、总inode数、挂载次数、挂载时间、文件系统状态等<br>超级重要！损坏了整个分区基本就废了（好在有备份superblock） |
| **Group Descriptor Table**<br>（组描述符表） | 描述当前这个块组的情况，也同时描述所有块组的情况（多个块组共享一份） | 包含：本块组的 block bitmap 在哪、inode bitmap 在哪、inode table 在哪、空闲块数、空闲inode数等 |
| **Block Bitmap**<br>（块位图）               | 记录本块组中哪些**数据块**已经被用了                         | 1个字节代表8个数据块，1=已用，0=空闲<br>你要新建文件，内核就来这里找0的位置 |
| **Inode Bitmap**<br>（inode位图）            | 记录本块组中哪些**inode是否被占用**                          | 同上，1=已分配，0=空闲                                       |
| **Inode Table**<br>（inode表）               | 存放本块组所有 inode 节点（不管用没用，都预分配好了）        | 一个文件 = 一个inode<br>这里是真正的“文件元数据仓库”         |
| **Data Blocks**<br>（数据块）                | 真正存放文件内容、目录内容的地方                             | 普通文件内容就在这里<br>目录的内容也是在这里（目录也是文件） |

#### 5. 动静态库
库是.o文件的集合，用于模块化（提供.h接口+.o实现）。关键点：
- **.o生成**：`gcc -c src.c`产生可重定位目标文件。
- **静态库（.a）**：`ar rcs libname.a *.o`打包。链接时拷贝到可执行文件（代码区，相对地址）。命令：`gcc main.c -l mymath -L /path`（-l掐头去尾，libmymath.a）。
- **动态库（.so）**：`gcc -shared -fPIC -o libname.so *.o`生成位置无关代码。运行时OS加载（共享区，动态地址：start+偏移）。链接：同静态，但需运行时查找（LD_LIBRARY_PATH、/etc/ld.so.conf+ldconfig、-rpath）。
- **加载区别**：
  - 静态：编译时嵌入，无需加载。
  - 动态：运行时映射，节省空间，支持更新。
- **推荐**：ncurses等第三方库安装类似。

**注意**：gcc默认动态链接；找不到库报错需指定-I（头文件）-L（库路径）；动态库路径优先环境变量→配置文件→rpath。

**整体复习**：文件描述符、软硬链接、缓冲刷新、文件系统位图、库链接。强调效率（缓冲/局部性）和安全性（权限/引用计数）。

### 附上代码
以下提取文档中所有C代码片段，按出现顺序编号，便于对照。每个代码块后标注简要说明。

#### 代码1: 写文件（fprintf, "w"模式）
```c
#include <stdio.h>    
#include <unistd.h>    
    
#define FILE_NAME "log.txt"    
    
int main()    
{    
  FILE* fp = fopen(FILE_NAME, "w"); // r w r+(读写，不存在出错) w+(读写，不存在出错)  a(append 追加) a+    
  if(NULL == fp)    
  {    
    perror("fopen");    
    return 1;    
  }    
    
  int cnt = 5;    
  while(cnt)    
  {    
    fprintf(fp, "%s:%d\n", "hello bit", cnt--);                                                                                                                              
  }    
    
  fclose(fp);    
    
  return 0;    
}  
```
**说明**：以"w"模式写5行，自动清空文件。

#### 代码2: 读文件（fgets, "r"模式）
```c
#include <stdio.h>    
#include <string.h>    
#include <unistd.h>    
    
#define FILE_NAME "log.txt"    
    
int main()    
{    
    
   FILE* fp = fopen(FILE_NAME, "r"); // r w r+(读写，不存在出错) w+(读写，不存在出错)  a(append 追加) a+    
    
   if(NULL == fp)    
   {    
     perror("fopen");    
     return 1;    
   }    
    
   char buffer[64];    
   while(fgets(buffer, sizeof(buffer) - 1, fp) != NULL)    
   {    
     buffer[strlen(buffer) - 1] = 0;                                                                                                                                         
      puts(buffer);    
   }    
    
   fclose(fp);  
  return 0;
 }
```
**说明**：逐行读文件，移除换行符。

#### 代码3: 追加写文件（fprintf, "a"模式）
```c
#include <stdio.h>    
#include <string.h>    
#include <unistd.h>    
    
#define FILE_NAME "log.txt"    
    
int main()    
{    
    
   FILE* fp = fopen(FILE_NAME, "a"); // r w r+(读写，不存在出错) w+(读写，不存在出错)  a(append 追加) a+    
    
   if(NULL == fp)    
   {    
     perror("fopen");    
     return 1;    
   }    
    
    
   int cnt = 5;    
   while(cnt)    
   {    
     fprintf(fp, "%s:%d\n", "hello bit", cnt--);    
   }    
    
   fclose(fp); 
   
   return 0;
 }
```
**说明**：追加5行到文件末尾。

#### 代码4: 位图标志演示
```c
#include <stdio.h>                                                                                                                                                           
#include <string.h>    
#include <unistd.h>    
    
// 每一个宏，对应的数据值，只有一个比特位是1，位置不重叠    
#define ONE   0x1  // (1<<0)    
#define TWO   0x2  // (1<<1)    
#define THREE 0x4  // (1<<2)    
#define FOUR  0x8  // (1<<3)    
    
void show(int flags)    
{    
  if(flags & ONE )   printf("one \n");    
  if(flags & TWO )   printf("two  \n");    
  if(flags & THREE ) printf("three  \n");    
  if(flags & FOUR )  printf("four  \n");    
}    
    
int main()    
{    
 show(ONE);    
 show(TWO);    
 show(ONE | TWO);    
return 0;
}    
```
**说明**：演示位或（|）组合标志。

#### 代码5: 系统调用写文件（write, O_APPEND）
```c
#include <stdio.h>    
#include <assert.h>    
#include <string.h>    
#include <unistd.h>    
#include <sys/types.h>    
#include <sys/stat.h>    
#include <fcntl.h>    
    
#define FILE_NAME "log.txt"    
    
int main()    
{    
      
  umask(0);    
  // c-- W > O_WRONLY | O_CREAT | O_TRUNC, 0666    
  /*    
   *int fd = open(FILE_NAME, O_WRONLY | O_CREAT | O_TRUNC, 0666);    
   */    
    
  int fd = open(FILE_NAME, O_WRONLY | O_CREAT | O_APPEND, 0666);    
  if(fd < 0)    
  {    
    perror("open");    
    return 1;    
  }    
    
  int cnt = 5;    
  char buffer[64];    
  while(cnt)    
  {                                                                                                                                                                          
    sprintf(buffer, "%s:%d\n", "harallo bit", cnt--);    
    // 你以斜杠零结尾是c语言规定的，和我文件有什么关系呢？    
    write(fd, buffer, strlen(buffer)); // strlen计算\0之前的数据, 这里面不写要写入 \0    
  }    
    
    
  /*    
   *printf("%d \n", fd);    
   */    
    
  close(fd);    
return 0
}
```
**说明**：用系统调用追加写，忽略\0。

#### 代码6: 系统调用读文件（read）
```c
#include <stdio.h>    
#include <assert.h>    
#include <string.h>    
#include <unistd.h>    
#include <sys/types.h>    
#include <sys/stat.h>    
#include <fcntl.h>    
    
#define FILE_NAME "log.txt"    
    
int main()    
{    
      
  umask(0);    
    
  int fd = open(FILE_NAME, O_RDONLY);    
  if(fd < 0)    
  {    
    perror("open");    
    return 1;    
  }    
    
  char buffer[1024];    
  ssize_t num = read(fd, buffer, sizeof(buffer) - 1);    
  if(num > 0) buffer[num] = 0;    
  printf("%s \n", buffer);    
    
  close(fd);    
 return 0
}
```
**说明**：一次性读文件内容。

#### 代码7: fd递增演示
```c
#include <stdio.h>      
#include <unistd.h>      
#include <string.h>      
#include <sys/types.h>      
#include <sys/stat.h>      
#include <fcntl.h>      
#include <assert.h>      
#include <stdlib.h>      
#include <unistd.h>      
    
#define FILE_NAME(number) "log.txt"#number      
    
int main()      
{      
     
 umask(0);
 printf("stdin->fd:%d\n",  stdin->_fileno);
 printf("stdout->fd:%d\n", stdout->_fileno);
 printf("stderr->fd:%d\n", stderr->_fileno);  
   
  int fd0 = open(FILE_NAME(1), O_WRONLY | O_CREAT | O_ASYNC, 0666);      
  int fd1 = open(FILE_NAME(2), O_WRONLY | O_CREAT | O_ASYNC, 0666);      
  int fd2 = open(FILE_NAME(3), O_WRONLY | O_CREAT | O_ASYNC, 0666);      
  int fd3 = open(FILE_NAME(4), O_WRONLY | O_CREAT | O_ASYNC, 0666);      
  int fd4 = open(FILE_NAME(5), O_WRONLY | O_CREAT | O_ASYNC, 0666);      
  int fd5 = open(FILE_NAME(6), O_WRONLY | O_CREAT | O_ASYNC, 0666);      
         
  printf("fd %d \n", fd0);      
  printf("fd %d \n", fd1);      
  printf("fd %d \n", fd2);      
  printf("fd %d \n", fd3);      
  printf("fd %d \n", fd4);      
  printf("fd %d \n", fd5);      
                   
  close(fd0);      
  close(fd1);      
  close(fd2);      
  close(fd3);      
  close(fd4);      
  close(fd5);      
                 
  return 0;      
}      
```
**说明**：打开6文件，fd从3-8递增。

#### 代码8: 输出重定向演示（close(1)）
```c
#include <stdio.h>    
#include <sys/types.h>    
#include <sys/stat.h>    
#include <fcntl.h>    
#include <unistd.h>    
    
int main()    
{    
    
   /*    
    *close(0);    
    */    
    
    close(1); //,标准输出的，显示器     
   
   /*    
    *close(2);    
    */    
    
  umask(0);    
  int fd = open("log.txt",O_WRONLY | O_CREAT | O_TRUNC, 0666);    
  if(fd < 0)    
  {    
    perror("open failed");    
    return 1;    
  }    
    
  printf("open fd %d \n", fd);    
  fprintf(stdout, "open fd %d \n", fd);    
  fflush(stdout);    // 这里必须刷新数据才能看到，因为缓冲区
                                                                                                                            
  close(fd);    
  return 0;     
}         
```
**说明**：关闭stdout后打开文件，实现重定向。

#### 代码9: dup2输出重定向（O_TRUNC）
```c
#include <stdio.h>    
#include <sys/types.h>    
#include <sys/stat.h>    
#include <fcntl.h>    
#include <unistd.h>    
#include <string.h>    
    
int main()    
{    
    
    
    
  umask(0);    
  int fd = open("log.txt",O_WRONLY | O_CREAT | O_TRUNC, 0666);    
  /*    
   *int fd = open("log.txt",O_WRONLY | O_CREAT | O_APPEND, 0666);    
   */                                                                                                                        
  if(fd < 0)    
  {    
    perror("open failed");    
    return 1;    
  }    
    
  // 现在1的位置是 fd了。现在输出数据是往fd里面了，而不是stdout(显示器了)    
  dup2(fd, 1);  // fd--->1    
    
    
    
  printf("open fd %d \n", fd); // 往stdout里面输出数据    
  fprintf(stdout, "open fd : %d \n", fd);    
    
  const char*msg = "hello world";    
  write(1,msg, strlen(msg));    
  fflush(stdout);    
    
    
    
  close(fd);    
  return 0;    
}    
```
**说明**：用dup2将fd复制到1，实现覆盖重定向。

#### 代码10: dup2追加重定向（O_APPEND）
```c
#include <stdio.h>    
#include <sys/types.h>    
#include <sys/stat.h>    
#include <fcntl.h>    
#include <unistd.h>    
#include <string.h>    
    
int main()    
{    
      
  umask(0);    
  /*    
   *int fd = open("log.txt",O_WRONLY | O_CREAT | O_TRUNC, 0666);    
   */    
      
  int fd = open("log.txt",O_WRONLY | O_CREAT | O_APPEND, 0666);    
  if(fd < 0)    
  {    
    perror("open failed");    
    return 1;    
  }    
    
  // 现在1的位置是 fd了。现在输出数据是往fd里面了，而不是stdout(显示器了)    
  dup2(fd, 1);  // fd--->1    
    
      
  printf("open fd %d \n", fd); // 往stdout里面输出数据    
  fprintf(stdout, "open fd : %d \n", fd);    
    
  const char*msg = "hello world";    
  write(1,msg, strlen(msg));    
  fflush(stdout);    
                                                                                                                            
  close(fd);    
  return 0;     
}               
```
**说明**：追加模式重定向。

#### 代码11: dup2输入重定向
```c
#include <stdio.h>    
#include <sys/types.h>    
#include <sys/stat.h>    
#include <fcntl.h>    
#include <unistd.h>    
#include <string.h>                      
int main()             
{    
    
  umask(0);    
  int fd = open("log.txt",O_RDONLY);    
  if(fd < 0)    
  {    
    perror("open failed");    
    return 1;    
  }    
    
  dup2(fd, 0); // 输入重定向                                                                                                                                                 
                                
  char line[64];    
  while(1)          
  {           
    printf("> ");    
                     
    if(fgets(line, sizeof(line), stdin) == NULL) // stdin read     
    {                                                              
      break;    
    }           
    printf("%s", line);    
  }                        
       
  close(fd);    
  return 0;     
}     
```
**说明**：从文件读输入到stdin。

#### 代码12: 简化Shell实现（第一版，有bug）
```c
#include <stdio.h>    
#include <string.h>    
#include <stdlib.h>    
#include <unistd.h>    
#include <sys/types.h>    
#include <sys/wait.h>    
#include <assert.h>    
#include <ctype.h>    
#include <sys/stat.h>    
#include <sys/types.h>    
#include <fcntl.h>    
#include <errno.h>    
    
#define NUM 1024    
#define OPT_NUM 64    
    
#define NONE_REDIR   0    
#define INPUT_REDIR  1    
#define OUTPUT_REDIR 2    
#define APPEND_REDIR 3    
    
#define trimSpace(start) do{\    
    while(isspace(*start)) ++start;\    
}while(0)    
    
int lastCode = 0;    
int lastSig = 0;    
    
char linecommand[NUM];    
char* myagrv[OPT_NUM];    
    
int redirType = NONE_REDIR;    
char* redirFile = NULL;    
    
//     
void commandCheck(char* command)    
{    
  assert(command != NULL);    
  char* start = command;    
  char* end = command + strlen(command);    
  while(start < end)    
  {    
    if(*start == '>')    
    {    
      *start = '\0';    
      start++;    
      if(*start == '>')    
      {    
        redirType = APPEND_REDIR;    
      }    
      else     
      {    
        redirType = OUTPUT_REDIR;    
      }    
    
      trimSpace(start);    
          
      redirFile = start;    
      break;    
    }    
    else if(*start == '<')    
    {    
      *start = '\0';    
      start++;    
      trimSpace(start);    
      redirType = INPUT_REDIR;    
      redirFile = start;    
      break;    
    }    
    else     
    {    
      start++;    
    }    
  }    
}    
    
    
    
    
int main()    
{    
    
    
      
  while(1)    
  {    
      
    // 初始化    
    redirType = NONE_REDIR;    
    redirFile = NULL;    
    errno = 0;    
  printf("用户名@主机名 当前路径# ");    
  fflush(stdout);    
    
  char* s = fgets(linecommand, sizeof(linecommand)-1, stdin);    
  assert(s != NULL);    
    
  (void)s;    
    
  // 清理最后一个\n    
  //    
  linecommand[strlen(linecommand) - 1] = 0;    
  //  printf("test %s\n", linecommand); 
  commandCheck(linecommand);    
    
  // " ls -a -l -h"    
  myagrv[0] = strtok(linecommand, " ");    
 
  int i = 1;
  if(myagrv[0] != NULL && strcmp(myagrv[0], "ls") == 0)
  {
    myagrv[i] =(char*) "--color=auto";
  }

  while((myagrv[i++] = strtok(NULL, " ")) != NULL)
  {
    ;
  }


  // 如果是cd指令，不需要创建子进程，让对应的shell执行。
  // 不需要子进程来执行，让shell自己执行----- 内建/内置命令
  if(myagrv[0] != NULL && strcmp(myagrv[0],"cd") == 0)
  {
    if(myagrv[1] != NULL) chdir(myagrv[1]);
    continue;
  }

  if(myagrv[0] != NULL && myagrv[1] != NULL && strcmp(myagrv[0], "echo") == 0 )
  {
    if( strcmp(myagrv[1],"$?") == 0) 
    {
      printf("%d, %d \n", lastCode, lastSig);
    }
    else 
    {
      printf("%s \n", myagrv[1]);
    }

    continue;
  }


  //测试 是否成功
  
/*
 *#ifdef DEBUG 
 *  for(int i = 0; myagrv[i]; i++)
 *  {
 *    printf("myagrv[%d], %s \n", i, myagrv[i]);
 *  }
 *#endif
 */

  // 执行命令 
  pid_t id = fork();
  assert(id != -1);

   if(0)
   {
      execvp(myagrv[0], myagrv);
      exit(1);
   }

   if(id == 0)
   {
     // 因为命令是子进程执行的，真正重定向的工作一定是子进程来完成的
     // 如何完成重定向， 是父进程要提供的信息、
     // 这里的重定向会影响父进程吗 进程具有独立性，不能影响父进程。拷贝struct_files
     
     switch(redirType)
     {
        case NONE_REDIR: 
          break;
        case INPUT_REDIR:
          {
            int fd = open(redirFile, O_RDONLY);
            if(fd < 0)
            {
              perror("open");
              exit(errno);
            }
            dup2(fd, 0);
          }
          break;
        case OUTPUT_REDIR:
        case APPEND_REDIR:
          {
            int flags = O_WRONLY | O_CREAT;
            if(redirType == APPEND_REDIR) flags |= O_APPEND;
            else flags |= O_TRUNC;

           int fd = open(redirFile, flags, 0666);
            if(fd < 0)
            {
              perror("open");
              exit(errno);
            }

            // 重定向文件已经打开了
            dup2(fd, 1);
          }
          break;
        default: printf("bug?\n");
          break;
     }
     execv(myagrv[0], myagrv); // 执行程序替换的时候，会不会影响曾经打开的重定向文件，不会的
     exit(1);
   }

   int status = 0;
   pid_t ret =  waitpid(id, &status, 0);
   assert(ret > 0);
   (void)ret;

   lastCode = (status>>8)&0xff;
   lastSig = status & 0x7f;
  }
  return 0;
}
```
**说明**：第一版Shell，支持基本重定向、内建命令，但有解析bug。

#### 代码13: 简化Shell实现（第二版，修复版）
```c
// shell_simple.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <assert.h>
#include <ctype.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>

#define NUM 1024
#define OPT_NUM 64

#define NONE_REDIR   0
#define INPUT_REDIR  1
#define OUTPUT_REDIR 2
#define APPEND_REDIR 3

#define trimSpacePtr(p) do { while (*(p) && isspace((unsigned char)*(p))) ++(p); } while(0)

int lastCode = 0;
int lastSig = 0;

char linecommand[NUM];
char* myagrv[OPT_NUM];

int redirType = NONE_REDIR;
char* redirFile = NULL;

/* 解析重定向（只支持简单形式：cmd ... > filename 或 >> filename 或 < filename）
   解析后会把命令中重定向符号位置置 '\0'（从而截断命令部分），并把 redirType 与 redirFile 设好。 */
void commandCheck(char* command)
{
    assert(command != NULL);
    char* p = command;
    while (*p) {
        if (*p == '>') {
            *p = '\0';            // 截断命令
            p++;
            if (*p == '>') {     // >> 追加
                redirType = APPEND_REDIR;
                p++;
            } else {
                redirType = OUTPUT_REDIR;
            }
            trimSpacePtr(p);
            if (*p == '\0') { redirFile = NULL; return; }
            // 找到文件名的结尾（空白或字符串结束）
            char* fname = p;
            char* q = fname;
            while (*q && !isspace((unsigned char)*q)) ++q;
            *q = '\0'; // 截断文件名后的内容
            redirFile = fname;
            return;
        } else if (*p == '<') {
            *p = '\0';
            p++;
            trimSpacePtr(p);
            redirType = INPUT_REDIR;
            if (*p == '\0') { redirFile = NULL; return; }
            char* fname = p;
            char* q = fname;
            while (*q && !isspace((unsigned char)*q)) ++q;
            *q = '\0';
            redirFile = fname;
            return;
        } else {
            ++p;
        }
    }
}

int main()
{
    while (1) {
        // 初始化/重置
        redirType = NONE_REDIR;
        redirFile = NULL;
        errno = 0;

        printf("用户名@主机名 当前路径# ");
        fflush(stdout);

        char* s = fgets(linecommand, sizeof(linecommand), stdin);
        if (s == NULL) {
            // EOF（例如 Ctrl+D），退出 shell
            printf("\nexit\n");
            break;
        }

        // 去掉末尾的换行（如果有）
        size_t len = strlen(linecommand);
        if (len > 0 && linecommand[len - 1] == '\n') linecommand[len - 1] = '\0';

        // 忽略空行
        char* tmp = linecommand;
        trimSpacePtr(tmp);
        if (*tmp == '\0') continue;

        // 解析重定向（会把重定向符号替换为 '\0'，并设置 redirType/redirFile）
        commandCheck(linecommand);

        // tokenization：先把命令部分拆成 tokens
        for (int i = 0; i < OPT_NUM; ++i) myagrv[i] = NULL;

        int argc = 0;
        char* token = strtok(linecommand, " \t");
        while (token != NULL && argc < OPT_NUM - 1) {
            myagrv[argc++] = token;
            token = strtok(NULL, " \t");
        }
        myagrv[argc] = NULL;

        if (argc == 0) continue;

        // 内建命令：cd
        if (strcmp(myagrv[0], "cd") == 0) {
            if (myagrv[1] != NULL) {
                if (chdir(myagrv[1]) != 0) perror("chdir");
            } else {
                // 没有参数切到 HOME
                char* home = getenv("HOME");
                if (home) chdir(home);
            }
            continue;
        }

        // 内建命令：echo $?
        if (strcmp(myagrv[0], "echo") == 0 && myagrv[1] != NULL) {
            if (strcmp(myagrv[1], "$?") == 0) {
                printf("%d, %d\n", lastCode, lastSig);
            } else {
                printf("%s\n", myagrv[1]);
            }
            continue;
        }

        // 如果是 ls，插入 --color=auto（插入到 argv[1]，并向后移动），并检查不越界
        if (argc >= 1 && strcmp(myagrv[0], "ls") == 0) {
            if (argc + 1 < OPT_NUM) {
                // 从后往前移动
                for (int i = argc; i >= 1; --i) {
                    myagrv[i + 0] = myagrv[i - 1]; // move including NULL at end
                }
                myagrv[1] = "--color=auto";
                argc += 1;
                myagrv[argc] = NULL;
            }
        }

        // fork + exec
        pid_t id = fork();
        if (id < 0) {
            perror("fork");
            continue;
        }

        if (id == 0) {
            // child: 处理重定向
            switch (redirType) {
                case NONE_REDIR:
                    break;
                case INPUT_REDIR: {
                    if (redirFile == NULL) {
                        fprintf(stderr, "input redirection file missing\n");
                        _exit(1);
                    }
                    int fd = open(redirFile, O_RDONLY);
                    if (fd < 0) {
                        perror("open input");
                        _exit(errno ? errno : 1);
                    }
                    if (dup2(fd, STDIN_FILENO) < 0) {
                        perror("dup2 input");
                        close(fd);
                        _exit(1);
                    }
                    close(fd);
                } break;
                case OUTPUT_REDIR:
                case APPEND_REDIR: {
                    if (redirFile == NULL) {
                        fprintf(stderr, "output redirection file missing\n");
                        _exit(1);
                    }
                    int flags = O_WRONLY | O_CREAT;
                    if (redirType == APPEND_REDIR) flags |= O_APPEND;
                    else flags |= O_TRUNC;
                    int fd = open(redirFile, flags, 0666);
                    if (fd < 0) {
                        perror("open output");
                        _exit(errno ? errno : 1);
                    }
                    if (dup2(fd, STDOUT_FILENO) < 0) {
                        perror("dup2 output");
                        close(fd);
                        _exit(1);
                    }
                    close(fd);
                } break;
                default:
                    break;
            }

            // execvp 会根据 PATH 查找可执行文件
            execvp(myagrv[0], myagrv);
            // execvp 只有在失败时返回
            perror("execvp");
            _exit(127);
        }

        // parent: 等待子进程
        int status = 0;
        pid_t ret = waitpid(id, &status, 0);
        if (ret < 0) {
            perror("waitpid");
            continue;
        }

        if (WIFEXITED(status)) {
            lastCode = WEXITSTATUS(status);
            lastSig = 0;
        } else if (WIFSIGNALED(status)) {
            lastCode = 128 + WTERMSIG(status); // convention
            lastSig = WTERMSIG(status);
        } else {
            lastCode = status;
            lastSig = 0;
        }
    } // while

    return 0;
}
```
**说明**：修复版Shell，支持EOF退出、空行忽略、cd到HOME、ls美化、退出码约定。

#### 代码14: 缓冲区fork演示
```c
#include <stdio.h>    
#include <sys/types.h>    
#include <sys/stat.h>    
#include <fcntl.h>    
#include <unistd.h>    
#include <string.h>    
int main()    
{    
  // 用户数据都要经过缓冲区域的    
  // c接口    
  printf("hello printf \n");    
  fprintf(stdout, "hello fprintf \n");    
  fputs("hello fputs \n", stdout);    
    
  // 系统调用接口                                                                                                                                                           
  const char* msg = "hello elifc \n";    
  write(1, msg, strlen(msg));    
    
  // 执行到这里的时候，还没有刷新数据    
  fork();    
    
  return 0;    
}    
```
**说明**：演示fork前缓冲未刷新导致重复输出。

#### 代码15: 缓冲区fork重定向演示
```c
#include <stdio.h>                                                                                                                         
#include <sys/types.h>    
#include <sys/stat.h>    
#include <fcntl.h>    
#include <unistd.h>    
#include <string.h>    
int main()    
{    
    
    
  // 用户数据都要经过缓冲区域的    
  // 用户接口    
  printf("hello printf------------------c\n");    
  fprintf(stdout, "hello fprintf--------c \n");    
  fputs("hello fputs--------------------c \n", stdout);    
    
    
    
  // 系统接口    
  const char* msg = "hello elifc-------------linux \n";    
  write(1, msg, strlen(msg));    
    
  // 执行到这里的时候，还没有刷新数据    
  fork();    
    
  // stdout默认是行刷新 ，fork之前，三条c函数已经数据输出到显示器了，你的FILE内部，进程进程内部不存在对应的数据了    
  // 进行了 > 写入文件不再是显示器了，而是普通文件了，采用的刷新策略全缓冲，c函数虽然有\n， 不足以将stdout缓冲区写满！    
  // 数据并没有被刷新。    
  //    
  // 执行fork时，stdout属于父进程，创建子进程，紧接着就是进程退出。但是谁先退出，一定要进行缓冲区刷新(就是修改)    
  // 发生写时拷贝    
  // 数据终止会显示两份    
  //    
  // wirte没有， write没有FILE, 用的是fd， 就没有c提供的缓冲区。    
    
    
  return 0;    
}    
```
**说明**：重定向到文件时，全缓冲导致fork重复。

#### 代码16: 自定义缓冲区头文件（myStdio.h）
```c
#pragma once                                                                                                                         
                                                                                                         
#include <assert.h>    
#include <stdlib.h>    
#include <errno.h>    
#include <sys/types.h>    
#include <unistd.h>    
#include <sys/stat.h>    
#include <fcntl.h>    
#include <string.h>    
    
#define SIZE      1024    
#define SYNC_NOW  1    
#define SYNC_LINE 2    
#define SYNC_FULL 4    
    
    
typedef struct _FILE    
{    
    int flags;      // 刷新方式    
    int fileno;     //     
    int cap;        // 总容量    
    int szie;       //  使用量    
    char buffer[SIZE];  //     
    
    
}FILE_;    
    
    
FILE_* fopen_(const char* path_name, const char* mode);    
void    fwrite_(const void* ptr, int num, FILE_* fp);    
void   fclose_(FILE_* fp);    
void fflush_(FILE_* fp);  
```
**说明**：自定义FILE结构体定义。

#### 代码17: 自定义缓冲区实现
```c
#include "myStdio.h"    
    
    
FILE_* fopen_(const char* path_name, const char* mode)    
{    
    int flags = 0;    
    int defaultMode=0666;    
    if(strcmp(mode, "r") == 0)    
    {    
      flags |= O_RDONLY;    
    }    
    else if(strcmp(mode, "w") == 0)    
    {    
      flags |= (O_WRONLY | O_CREAT | O_TRUNC);    
    }    
    else if(strcmp(mode, "a") == 0)    
    {    
      flags |= (O_WRONLY | O_CREAT | O_APPEND);    
    }    
    else    
    {    
      // todo                                                                                                                     
    }    
    
    
    int fd = 0;    
    
    
    if(flags & O_RDONLY) fd = open(path_name, flags);    
    else fd = open(path_name, flags, defaultMode);    
    
    
    if(fd < 0)    
    {    
      const char* err = strerror(errno);    
      write(2, err, strlen(err));    
      return NULL;    
    }    
    
    
    
    FILE_* fp = (FILE_*)malloc(sizeof(FILE_));    
    
    
    assert(fp);    
    
    
    fp->flags = SYNC_LINE;    
    fp->fileno = fd;    
    fp->cap = SIZE;    
    fp->szie = 0;    
    memset(fp->buffer, 0, SIZE);    
    
    
    
    return fp; // 这就是为什么打开一个文件，就会返回一个FILE* 指针    
}    
    
    
void fwrite_(const void* ptr, int num, FILE_* fp)    
{    
  // 数据写入到缓冲区中    
   memcpy(fp->buffer + fp->szie, ptr, num); // 不考虑缓冲区的溢出    
    
    
   fp->szie += num;    
   // 判断是否刷新    
    
    
   if(fp->flags & SYNC_NOW)    
   {    
    write(fp->fileno, fp->buffer, fp->szie);    
    fp->szie = 0; // 清空缓冲区    
   }    
   else if(fp->flags & SYNC_FULL)    
   {    
     if(fp->szie == fp->cap)    
     {    
        write(fp->fileno, fp->buffer, fp->szie);    
        fp->szie =  0;    
     }    
   }    
   else if(fp->flags & SYNC_LINE)    
   {    
      if(fp->buffer[fp->szie-1] == '\n')    
      {    
        write(fp->fileno, fp->buffer, fp->szie);    
        fp->szie =  0;    
      }    
   }    
   else    
   {    
    
    
   }    
}    
    
    
void fflush_(FILE_* fp)    
{    
  // 写到系统里面    
  if(fp->szie > 0)write(fp->fileno, fp->buffer, fp->szie);    
    
    
  // 真正的刷新    
  // 内核缓冲区到----磁盘文件的
  fsync(fp->fileno);    
  fp->szie = 0;    
}    
    
    
void fclose_(FILE_* fp)    
{    
  fflush_(fp);    
  close(fp->fileno);    
}    
```
**说明**：实现自定义IO函数，支持不同刷新策略。

#### 代码18: 自定义缓冲区测试
```c
#include "myStdio.h"                                                                                                                        
    
int main()    
{    
    
    
  FILE_* fp = fopen_("./log.txt","w");    
    
    
  if(fp == NULL)    
  {    
    return 1;    
  }    
    
    
  const char* msg = "helllo \n";    
    
    
  int cnt = 18;    
  while(cnt)    
  {    
    fwrite_(msg, strlen(msg), fp);    
    sleep(1);    
    if(cnt % 3 == 0) fflush_(fp);    
    cnt--;    
  }    
    
    
  fclose_(fp);    
  return 0;    
}    
```
**说明**：测试循环写+周期刷新。

这些代码覆盖了文档核心示例。如果你需要特定代码的解释、修改或运行结果模拟，请提供更多细节！