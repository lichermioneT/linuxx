进程的PCB属性，关于信号的位图结构
信号的也是内核数据结构，同样只能直接接触的

kill指令可以往任何进程发送任意信号
raise()自己给自己发送信号的
abort()自己给自己发送信号的

关于信号处理的行为理解：有很多的情况，进程收到大部分的信号。默认处理动作都是终止进程
信号的意义：信号的不同，代表不同的事件，但是对事件发生之后的处理动作可以一样的

10/0
CPU里面有很多状态寄存器，溢出标记位。
CPU运算异常
OS识别问题

进程收到信号不一定会影响进程退出，没有退出还有可能被调度
CPU内部寄存器只有一份，但是寄存器中的内容，属于当前进程的上下文
你有能力解决吗？不能的
当进程被切换的时候，就有无数次状态寄存器被保存和恢复
每一次恢复的时候，就让OS识别到了CPU内部的状态寄存器的标志位是1

OS怎么知道我野指针了呢？
虚拟地址----页表+MMU----物理内存。MMU出现异常了，OS马上发送信号给出现异常的进程。

软件条件产生异常
  管道
  读端关闭
  写端开启---->OS不允许

访问外设很慢的！！！

闹钟为什么就是软件呢？
  实际上闹钟就是软件实现的
  任何一个进程，都可以通过alarm系统掉用在内核中设置闹钟，OS可能会存在很多的闹钟，OS要不要管理这些闹钟呢？
  先描述，后组织！
 
struct alarm
{
  uint64 when; 未来时间
  int type; 一次性or周期性
  task_struct*p;那个进程的
  struct alarm* next;
}

struct alarm* head
1,2,3,4,5
OS会周期性的检查这些闹钟，
cur_time > alarm.when:超时了，
OS发送SIGALARM-> alarm.p
也可以建立堆或者队列
超时就是靠软件实现的

上面所说的所有信号产生，最终都要有OS来进行执行，为什么？OS是进程的管理者
信号的处理是否是立即处理的？在合适的时候
信号如果不是被立即处理，那么信号是否需要暂时被进程记录下来？记录在哪里最合适呢？
一个进程在没有收到信号的时候，能否能知道，自己应该对合法信号作何处理呢？
如何理解OS向进程发送信号？能否描述一下完整的发送处理过程？

退出时的核心问题，核心转储
  云服务器上，默认是关闭的 
  ulimit -c 1024打开核心存储的文件
当进程出现异常的时候，我们将进程对应的时候，在内存中的数据转储到磁盘中，核心转储！

为什么要有核心转储的？
  为什么崩溃，哪里崩溃？
  用来支持调试

如何支持呢？
 gdb core-file core.pid 


预备 信号的产生  信号的保存  信号的处理
9号信号是不能够进行捕捉的！！！




