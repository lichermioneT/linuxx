进程退出码
  判断子进程
  当它出现异常

阻塞
非阻塞

进程程序替换
  让子进程执行一个全新的程序

本质子进程的
  
如何替换
  7个函数
  找到程序
  如何执行程序

程序替换是系统级别的替换

环境变量可以被子进程继承下去
  系统的环境变量
  自己全新的环境变量
  execve最基本的函数
  其它都是封装了这个函数，为了满足不同的场景。
什么是当前路径

自己shell

基础io
重新谈论文件

1空文件也要在磁盘占空间
2文件== 内容 + 属性
3文件操作 == 属性操作 + 内容操作 + (文件内容 + 文件属性 )
4标定一个问题  必须使用 文件路径  + 文件名 唯一性
5如果没有默认指定文件路径，默认是在当前路径访问文件  进程当前路径
6fopen fclose fread fwrite 等接口写完之后，代码编译之后，形成二进制文件之后，但是没有运行 文件对应的操作没有被执行！
  对文件的操作本质是进程对文件的操作
7一个文件没有被打开，可以被直接访问吗？ 不可以的. 一个文件要被访问，就要打开。被我们的进程打开。
    用户进程+OS   是不是所有磁盘的文件都被打开？不是的
                  被打开的
                  没有被打开的 文件系统

结论：文件操作的本质：进程和被打开文件的关系。

重谈文件操作
1.c语言，c++，java, python, php, go , shell? 操作接口都不一样的。
  文件在哪里呢>>>>磁盘--》硬件---》os---》所有人想访问磁盘，都不能绕过os---》》使用os提供的接口--》可以，操作系统只有一个
  ---》上层语言无论如何变化，

  a库函数必须 调用 系统调用接口
  b库函数可以千变万化，但是底层不变--- 如何降低学习成本呢？

2.操作
  c语言


c语言传标记为，int--》一个标记位
          32个比特位。通过比特位传递选项。
            

sszie_t write(int fd, const void * buf, size_t count)  文本类，二进制类。是c语言提供给你的。
                        操作系统看来都是二进制位。

fopen fclose fwrite fread fseek
open  close  write    read     lseek
库函数封装系统调用接口

如何理解这里的文件呢？
  文件操作的本质：进程和被打开文件的关系
  1.进程可以打开多个文件吗？ 可以的！ 系统中一定会存在大量的被打开的文件。被打开的文件要不要被OS管理起来呢？(要的)
    如何管理呢？(先描述，后组织)  操作系统为了管理对应的打开文件吗，必定要为文件创建对应的内核数据结构标识文件

    struct file{} 包含了文件的大部分属性

为什么fd是从3开始的呢？
stdin  键盘
stdout 显示器
stderr 显示器

FILE* fp = fopen()
FILE*是什么呢？是一个结构体！必定有一个字段 (文件描述符号)

#include<stdio.h>
extern FILE* stdin
extern FILE* stdout
extern FILE* stderr


struct task_struct
{
  int fd open()
  struct files_struct* files;


  close(fd);
}

strcut files_struct{}

struct file* fd_array[]
进程的文件描述符表



struct file 
{
  键盘
  显示器
  显示器
  文件
}


文件描述符的本质就是数组的下标。
  2.

如何理解 键盘 显示器， 显示器这些东西也是文件呢？

内建指令
当前路径
文件
