进程状态
  阻塞
  挂起
  运行
static const char * const task_state_array[] = {
"R (running)", /* 0 */
"S (sleeping)", /* 1 */
"D (disk sleep)", /* 2 */
"T (stopped)", /* 4 */
"t (tracing stop)", /* 8 */
"X (dead)", /* 16 */
"Z (zombie)", /* 32 */
};

  PCB在运行队列等---运行状态
  PCB在阻塞队列等---阻塞状态
  挂起PCB在内存里面--code和data在磁盘里面。
  

IO密集型
计算密集型

kill 


小t状态可以是调试，它的信息可以被追踪。
  断点停下来


Z状态
僵尸状态
  为什么会有僵尸状态?

进程被创建处理---完成任务---1.要知道它完成的怎么样 2.可以不关心结果。
  Linux你可以不用，但是我必须保存的。
  进程退出的时候，不能立即释放进程对应的资源，保存一段时间，让父进程或者OS来进行读取。

僵尸状态是一个问题我们不解决的！
  不回收僵尸状态--可能会造成内存泄漏

僵尸状态是指：一个进程已经执行完毕并退出，但其在进程表中的条目仍然存在，等待父进程读取其退出状态信息的状态。

孤儿进程
  父进程先退出。
  给操作系统1号进程领养。
  不领养，对应的僵尸，没有人能够回收了。
  被领养的进程就是--孤儿进程。
  如果是前台进程创建的子进程，如果孤儿了，后台进程了。


操作系统也是一个进程。



进程优先级
  1.什么叫做优先级
  优先级是有执行的权利，只不过是谁先完成后完成的过程。  

  2.为什么会存在优先级
  为什么存在优先级？因为资源太少了。

  3.Linux的优先级
  优先级本质就是PCB里面的整数。

linux支持进程优先级调整的
  pri 默认80
  ni [-20, 19]
  
  优先级的取值范围[60,99]


进程的竞争性：优先级
进程的独立性：多进程运行，需要独享各种资源，多进程运行期间互不干扰。子进程和父进程也是相互独立性的。
并行：多个进程在多个CPU下分别，同时进行运行，这称之为并行。任何时刻只能有一个进程正在运行。
并发：多个进程在一个CPU下采用进程切换的方式，在一段时间之内，让多个进程都得以推进，称之为并发。

  CPU里面很多寄存器，
  pc(eip)寄存器,当前正在执行指令的下一条指令。
   

cpu
1.取指令
2.分析值
3.执行指令
  当我们的进程在运行的时候，一定会产生很多的临时数据。这份数据属于当前进程！！
  CPU虽然只有一堆寄存器硬件，寄存器里面保存的数据，是属于当前进程的。
  寄存器硬件 !=寄存器内的数据。
  进程在运行的时候占CPU，进程不是占有到进程结束！！(while(1))
  进程在运行的时候都有自己的时间片，(离开学校，保留学籍的过程，上下文保护。)(回到学校，恢复学籍，上下文恢复。)
  寄存器(寄存，寄存，寄存进程的临时数据。)。

进程切换的时候，要进程上下文保护。
当进程恢复的时候，要进程上下文恢复。
  

环境变量
 ls,pwd,touch which都是程序。 

要执行一个程序或者指令，先找到这个程序。
 /usr/bin/

// 可执行的文件的路径
ehco $PATH

// export指令

which就是PATH里面去找
  环境变量

























































































