复习
环境变量
  系统层面的全局变量
  USER
  PWD
  HOME


命令行参数
  根据选项选择不同的功能
  main函数的两张表 选项和环境变量
  getenv 建议
  evn
  char** environ

echo是shell内置命令，所以能够打印本地环境变量

c/c++的空间不是实际的物理地址
虚拟地址，线性地址，逻辑地址。

进程地址空间---》操作系统给进程话的饼干。

地址空间的本质：是内核的一种数据结构。



struct mm_struct
{

};

1.地址空间的描述的基本空间大小是字节
2.32位---2^32个地址
3.2^32 * 1字节 = 4GB的空间范围
4.每一个字节唯一的地址

2^32个地址保证唯一性就行了。
32位的数据即可


编址
1111111111111111111111111111111111111111
0000000000000000000000000000000000000000


默认就是2^32次方个地址。
unsigned int(32bits)

struct mm_struct
{
  uint32_t code_start;
  uint32_t code_end;
  uint32_t data_start;
  uint32_t data_end;
  uint32_t heap_start;
  uint32_t heap_end;
  uint32_t stack_start;
  uint32_t stack_end;
};

[start, end]---[起始地址，区域结束地址]
struct mm_struct* p =  (struct mm_struct*)malloc(sizeof(struct mm_struct));
------无法修改--------
p>code_start = ;
p->code_end = ;
p->data_start = ;
p->data_end = ;

-----堆栈可以调整------(本质就是修改end或者start)
定义局部变量，malloc ,new---->扩大堆栈区域
函数调用完毕，freee, delete-->缩小堆栈区域
p->heap_start = ;
p->heap_end = ;
p>stack_start = ;
p->stack_end = ;

mm_struct(4GB的空间操作系统都给你了！！！)


task_struct
{
  struct mm_struct* mm;
};



区域划分
struct desktop
{
  unsigned int man_start;
  unsigned int man_end;


  unsigned int woman_start;
  unsigned int woman_end;

}

struct desktop d = {1, 50, 51, 100};
区域调整

struct desktop fix = {1, 45, 55, 100};

区域调整
struct desktop new = {1, 30, 31, 100};



task_struct
{
  struct mm_struct* mm
}

mm-> {进程地址空间} --> {内存}<-----{磁盘}
my.exe加载到内存1k 字节的空间。


4GB/4KB
内存和磁盘io的单位
page--4kb


页表
虚拟地址    页表      物理地址
虚拟地址通过页表映射到物理地址

页表是一个多级页表

页表映射都是OS
load my.exe是me.

二维数组
进程地址空间
线性地址
逻辑地址


c/c++的地址空间应该是进程地址空间。
进程地址空间


进程都认为自己独享内存(虚拟地址空间)

如何理解进程地址空间呢？
为什么存在进程地址空间呢？？
  1.如果让进程直接访问物理内存，万一进程越界非法操作呢？非常不安全呢！(页表不仅仅只做映射，还会检查映射是否安全呢) 安全！所以进程都必须要遵守的。
  2.地址空间的存在可以更方便，进程和进程的数据代码的解耦，保证了进程的独立性的特征。
  3.让进程以同一的视角，来看待进程对应的代码和数据等各个区域，方便
    编译器也以统一的视角进行编译代码。
    规则一样的，编译完即可直接使用的。


写时拷贝---写的时候就进行拷贝。
任何一方尝试写入
OS先进行数据拷贝，更改页表映射，然后再让进程进行修改。
操作系统为了保证进程的独立性，做了很多工作，通过地址空间，让不同的进程，映射到不同的物理地址内存处。

1.每个进程有自己的独立内核数据结构
2.写时拷贝不同的数据进行分离。
  进程 == 内核数据结构 + 进程对应的代码和数据。

task_struct
{
  struct mm_strcut* mm;
}

mm---> struct mm_strcut{}

1.你的可执行程序里面，有没有地址呢？(没有被加载到内存的时候？)  内部早就有地址啦！！ 
2.虚拟地址空间，你不要以为只要OS会遵守对应的规则，编译也要遵守对应的规则。
  编译器编译你的代码，就是按照虚拟地址空间的方式进行对我们的代码和数据进行编译的。
  main------------调用--------------func  程序内部使用的地址
                页表映射
  main------------调用--------------func 
  
  代码要占空间！ 加载内存天然就有物理地址
  当程序被加载到内存的时候，天然就具有外部的物理地址，
  
  cpu是虚拟地址----------页表----------------内存(load到内存)
  

第二遍
task_struct
{
  struct mm_struct* mm
}

mm_struct
{

}

main()------------调用---------------------func() // 编译链接完成就已经有地址了
cpu执行指令的时候是虚拟地址，然后页表映射到物理内存

my.exe内部的地址
load my.exe物理的地址

cpu读取my.exe的内部地址
页表映射到物理地址。

1.标识物理内存中代码和数据的地址。
2.在程序内部互相跳转的时候的虚拟地址。

CPU读进来的都是指令
指令部分就有地址(虚拟地址)

CPU压根就没有见到物理地址！

为什么叫做线性地址
一直增加就行了。


磁盘是逻辑地址
