动静态链接
  自己写的代码和库是两码事
  c标准库，是别人已经写好了的，我们直接使用。
  我们使用库中函数的代码，我们写了函数的调用，没有函数的实现
  只有当链接的时候，对应的代码才和我们的代码关联起来。

  链接的本质：我们的调用库函数的时候，和标准库是如何关联起来的？

动态链接：
  int x = 10;
  int z = 100;
  printf("helll"); 去标准库里面找
  
静态链接：
  int x = 10;
  int z = 100;
  printf("helll");  写在文件里面,拷贝一份。


动态链接形成的文件小
  体积小加载大内存更方便
  节省资源，内存，磁盘，网络。
静态链接形成的文件大
  不受库升级和删除的影响
  形成的可执行程序体积大，网络，磁盘，内存。


bit
byte

// -o output
gcc test.c -o mytest


file mytest
List Dynamic Dependencies

// 动态库
libxxxx.so
// 静态库
libyyyy.a

默认是动态库
我们的指令
file /usr/bin/ls
ldd /usr/bin/ls

这个库的程序很多，但是库有几份？一份。
动态库--->共享库

下载一个c语言写的软件，还需要下载c标准库吗？


静态链接是拷贝静态库的代码。
  系统里必须存在.a结尾的静态库。

一般而言系统自动携带动态库。大量的c/c++代码需要动态库。
静态库一般需要自己安装



系统为了我们能够编程提供了
  1.系统给我们提供 标准库.h(告诉我们怎么用) 
  2.标准的动静态库(告诉们，方法我有实现，来找我吧)
  
  我的程序 = 我的代码 + 库的代码 = 可执行程序


windows下原理一样的
  动态.dll
  静态.lib



gdb等一会讲
  
makefile
make是一个命令
makefile是一个文件


makefile存在的意义就是为了构建项目

依赖关系：第一行
依赖方法：第二行
源文件没有编写，make不会再编译的
大型项目编译会很费时间的

伪目标的意义
.PHONY修饰的命令，总是被执行的

gcc/g++是如何知道我的文件需要重新编译呢？

access:访问时间的变化，不一定会马上访问马上修改的。
modify:修改文件的内容
change:文件的属性(修改了文件的内容，文件的属性就会改变的)

文件内容一般是访问多一些。(访问不一定修改，修改一定访问的)
access被更改的时间太多了，就需要更多次的IO
R权限给你了，不关心你的访问时间。访问一段时间才会修改的。


gcc/g++是如何知道我的文件需要重新编译呢？
  1.源文件和可执行程序
  2.第一次可执行的modify >>> 源文件的modify
  3.修改源文件的  
  4.源文件的modify >>> 可执行程序的时间


touch 更新文件的时间
.PHONY 不管modify时间和可执行程序的时间
每次到给我直接执行

make默认执行第一条指令
make默认只形成一个可执行文件

gcc -E test.c -o test.i
gcc -S test.i -o test.s
gcc -c test.s -o test.o
gcc test.o -o test

回车：回到行首 \r
换行：换行


































